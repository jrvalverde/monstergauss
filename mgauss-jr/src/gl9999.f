C/    GL9999       29 MAY 91                                         MRP
      SUBROUTINE NWIORD (IUNIT, IBUFF, NWORDS, ZWAIT, ZNAME, IERR, *)
C
C     NO-WAIT ASYNCHRONOUS READ ROUTINE.
C
C     AUTHOR: MIKE PETERSON, U OF T CHEMISTRY DEPARTMENT.
C     VERSION: JUNE 1989.
C
C     ARGUMENTS:
C     IUNIT  - UNIT NUMBER.
C     IBUFF  - BUFFER ADDRESS (INTEGER ONLY).
C     NWORDS - NUMBER OF WORDS TO READ.
C     ZWAIT  - LOGICAL VALUE WHICH IS .TRUE. TO WAIT FOR COMPLETION,
C              .FALSE. TO RETURN AFTER READ INITIATED.
C     ZNAME  - CHARACTER VARIABLE CONTAINING THE NAME OF THE CALLING
C              ROUTINE (NORMALLY 6 CHARACTERS LONG).
C     IERR   - ERROR FLAG THAT IS SET TO -2 IF AN ERROR OCCURS.
C              OTHERWISE, THE VALUE OF IERR IS UNCHANGED.
C     *      - ERROR RETURN ADDRESS (IERR WILL SET TO -2 ON ANY
C              ERROR CONDITION.
C
C     NOTE: THE FILE MUST CONTAIN AN INTERNAL END-OF-FILE MARKER/FLAG,
C     AND MUST NOT DEPEND ON FORTRAN TO DETECT THE END-OF-FILE, AS THIS
C     WILL CAUSE MONSTERGAUSS TO ABORT.
C
      COMMON /IO/ IN, IOUT, IODUM(215)
C
      LOGICAL ZWAIT
C
      CHARACTER*(*) ZNAME
C
      DIMENSION IBUFF(NWORDS)
C?VAX/UNX
      DATA NPASS/0/
C??
C
C     DO THE READ OF NWORDS WORDS.
C?GLD
C     CALL BUFFERIN (IUNIT, 1, IBUFF, NWORDS)
C??
C?GBR
C     CALL FTNNWIO_IN (IUNIT, 1, IBUFF, 4*NWORDS, 0, 0)
C??
C?IBM
C     READ (IUNIT, ID=IUNIT) IBUFF
C??
C?CDC
C     BUFFERIN (IUNIT,1) (IBUFF(1),IBUFF(NWORDS))
C??
C?VAX/UNX
      READ (IUNIT,ERR=9000,END=9100,IOSTAT=ISTAT) IBUFF
      NPASS = 0
C??
C     WAIT FOR I/O COMPLETION, UNLESS WAIT I/O ALREADY USED.
C?GLD/GBR/IBM/CDC
C     IF (.NOT. ZWAIT) RETURN
C     CALL NWIOWT (IUNIT, NWORDS, .FALSE., ZNAME, IERR, *9900)
C??
      RETURN
C
C     ERROR EXIT - I/O ERROR ON UNIT IUNIT.
C?VAX/UNX
 9000 WRITE (IOUT,9001) ISTAT, IUNIT, ZNAME
 9001 FORMAT ('0*** ERROR STATUS =',I15,' DURING READ FROM UNIT ',I3,
     1 ' IN NWIORD, CALLED FROM ROUTINE ',A)
      IERR = -2
      GO TO 9900
C*    SPECIAL END-OF-FILE HANDLING FOR NON-NO-WAIT SYSTEMS:
C*    ON THE FIRST E-O-F, BACKSPACE THE FILE AND LET EVERYTHING
C*    APPEAR NORMAL, PROVIDED NO-WAIT MODE WAS ORIGINALLY REQUESTED,
C*    AS THE USER WAS PROBABLY ATTEMPTING DOUBLE BUFFERING, AND SO
C*    ATTEMPTED TO READ THE BUFFER AFTER THE E-O-F.
 9100 IF (.NOT.ZWAIT .AND. NPASS.EQ.0) THEN
         NPASS = 1
         BACKSPACE IUNIT
         RETURN
      END IF
      WRITE (IOUT,9101) IUNIT, ZNAME, NPASS, ZWAIT
 9101 FORMAT ('0*** END-OF-FILE FOUND DURING READ FROM UNIT ',I3,
     1 ' IN NWIORD, CALLED FROM ROUTINE ',A/5X,'NPASS =',I4,
     2 ', ZWAIT = ',L1)
      IERR = -2
C??
 9900 RETURN 1
      END
      SUBROUTINE NWIOWR (IUNIT, IBUFF, NWORDS, ZWAIT, ZNAME, IERR, *)
C
C     NO-WAIT ASYNCHRONOUS WRITE ROUTINE.
C
C     AUTHOR: MIKE PETERSON, U OF T CHEMISTRY DEPARTMENT.
C     VERSION: JUNE 1989.
C
C     ARGUMENTS:
C     IUNIT  - UNIT NUMBER.
C     IBUFF  - BUFFER ADDRESS (INTEGER ONLY).
C     NWORDS - NUMBER OF WORDS TO WRITE.
C     ZWAIT  - LOGICAL VALUE WHICH IS .TRUE. TO WAIT FOR COMPLETION,
C              .FALSE. TO RETURN AFTER WRITE INITIATED.
C     ZNAME  - CHARACTER VARIABLE CONTAINING THE NAME OF THE CALLING
C              ROUTINE (NORMALLY 6 CHARACTERS LONG).
C     IERR   - ERROR FLAG THAT IS SET TO -2 IF AN ERROR OCCURS.
C              OTHERWISE, THE VALUE OF IERR IS UNCHANGED.
C     *      - ERROR RETURN ADDRESS (IERR WILL SET TO -2 ON ANY
C              ERROR CONDITION.
C
C     NOTE: THE FILE MUST CONTAIN AN INTERNAL END-OF-FILE MARKER/FLAG,
C     AND MUST NOT DEPEND ON FORTRAN TO DETECT THE END-OF-FILE, AS THIS
C     WILL CAUSE MONSTERGAUSS TO ABORT.
C
      COMMON /IO/ IN, IOUT, IODUM(215)
C
      LOGICAL ZWAIT
C
      CHARACTER*(*) ZNAME
C
      DIMENSION IBUFF(NWORDS)
C
C     DO THE WRITE OF NWORDS WORDS.
C?GLD
C     CALL BUFFEROUT (IUNIT, 1, IBUFF, NWORDS)
C??
C?GBR
C     CALL FTNNWIO_OUT (IUNIT, 1, IBUFF, 4*NWORDS, 0, 0)
C??
C?IBM
C     WRITE (IUNIT, ID=IUNIT) IBUFF
C??
C?CDC
C     BUFFEROUT (IUNIT,1) (IBUFF(1),IBUFF(NWORDS))
C??
C?VAX/UNX
      WRITE (IUNIT,ERR=9000,IOSTAT=ISTAT) IBUFF
C??
C     WAIT FOR I/O COMPLETION, UNLESS WAIT I/O ALREADY USED.
C?GLD/GBR/IBM/CDC
C     IF (.NOT. ZWAIT) RETURN
C     CALL NWIOWT (IUNIT, NWORDS, .FALSE., ZNAME, IERR, *9900)
C??
      RETURN
C
C     ERROR EXIT - I/O ERROR ON UNIT IUNIT.
C?VAX/UNX
 9000 WRITE (IOUT,9001) ISTAT, IUNIT, ZNAME
 9001 FORMAT ('0*** ERROR STATUS =',I15,' DURING WRITE TO UNIT ',I3,
     1 ' IN NWIOWR, CALLED FROM ROUTINE ',A)
      IERR = -2
C??
 9900 RETURN 1
      END
      SUBROUTINE NWIOWT (IUNIT, NWORDS, LSTBUF, ZNAME, IERR, *)
C
C     NO-WAIT ASYNCHRONOUS I/O WAIT ROUTINE.
C
C     AUTHOR: MIKE PETERSON, U OF T CHEMISTRY DEPARTMENT.
C     VERSION: JUNE 1987.
C
C     ARGUMENTS:
C     IUNIT  - UNIT NUMBER.
C     NWORDS - NUMBER OF WORDS TO READ.
C     LSTBUF - LOGICAL VALUE THAT IS .TRUE. IF THIS IS THE LAST
C              BUFFER, OR .FALSE. IF NOT LAST. SETTING LSTBUF TO .TRUE.
C              CAUSES ALL END-OF-FILE/ERROR/LENGTH CHECKING TO BE
C              SUPPRESSED FOR THE BUFFER THAT WAS READ PREVIOUSLY BY
C              NWIORD (IT IS ASSUMED THAT THE CALLING PROGRAM ALREADY
C              KNOWS THAT THE LAST BUFFER HAS BEEN READ DUE TO SOME
C              INTERNAL END-OF-FILE MARKER, AND THESE ROUTINES WILL NOT
C              WORK CORRECTLY IF THE CALLER IS DEPENDING ON FORTRAN
C              TO DETECT THE END-OF-FILE). THIS PARAMETER SHOULD ALWAYS
C              BE SET TO .FALSE. WHEN USED IN COMBINATION WITH NWIOWR
C              (I.E. WHEN WRITING THE FILE).
C     ZNAME  - CHARACTER VARIABLE CONTAINING THE NAME OF THE CALLING
C              ROUTINE (NORMALLY 6 CHARACTERS LONG).
C     IERR   - ERROR FLAG THAT IS SET TO -2 IF AN ERROR OCCURS.
C              OTHERWISE, THE VALUE OF IERR IS UNCHANGED.
C     *      - ERROR RETURN ADDRESS (IERR WILL SET TO -2 ON ANY
C              ERROR CONDITION.
C
      COMMON /IO/ IN, IOUT, IODUM(215)
C
      LOGICAL LSTBUF
C
      CHARACTER*(*) ZNAME
C
C     WAIT FOR I/O COMPLETION.
C?GLD
C     CALL M:WAIT (IUNIT)
C     CALL STATUS (IUNIT, ISTAT, NBYTES)
C     IF (ISTAT.NE.2 .OR. NBYTES.NE.4*NWORDS) GO TO 9000
C??
C?GBR
C     CALL MPXEAWAIT (0, ISTAT)
C     IUNITGBR = IUNIT
C     CALL FTNNWIO_ST (IUNITGBR, ISTAT, NBYTES)
C     IF (ISTAT.NE.0 .OR. NBYTES.NE.4*NWORDS) GO TO 9000
C??
C?IBM
C     WAIT (IUNIT, ID=IUNIT, COND=ISTAT)
C     IF (ISTAT .NE. 1) GO TO 9000
C??
C?CDC
C     ISTAT = UNIT (IUNIT)
C     NBYTES = LENGTH (IUNIT)
C     IF (ISTAT.GE.0 .OR. NBYTES.NE.NWORDS) GO TO 9000
C??
C?VAX/UNX DO NOTHING AS ALL I/O IS UNFORMATTED WAIT I/O.
      CONTINUE
C??
      RETURN
C
C     ERROR EXIT - I/O ERROR ON UNIT IUNIT.
C?GLD/GBR/IBM/CDC
C9000 IF (LSTBUF) RETURN
C     WRITE (IOUT,9001) ISTAT, IUNIT, ZNAME
C9001 FORMAT ('0*** ERROR STATUS =',I15,' DURING NO-WAIT I/O ON UNIT ',
C    1 I3,' IN NWIOWT, CALLED FROM ROUTINE ',A)
C     IERR = -2
C??
C?GLD/GBR
C     NEED = 4 * NWORDS
C     WRITE (IOUT,9002) NBYTES, NEED
C9002 FORMAT (' (NO-WAIT I/O TRANSFERRED',I10,' OF',I10,' BYTES)')
C??
C?CDC
C     WRITE (IOUT,9002) NBYTES, NWORDS
C9002 FORMAT (' (NO-WAIT I/O TRANSFERRED',I10,' OF',I10,' WORDS)')
C??
C?GLD/GBR/IBM/CDC
C     RETURN 1
C??
      END
      SUBROUTINE FREEFM(LINE,ICOL,ILAST,ITYPE,IDEL,NDEL,
     1 IA,NIA,NCHAR,INTEGR,REALNO,LAST,ISEP,IERR)
C*
C     SUBROUTINE TO SIMULATE FREE-FORMAT INPUT OF ALPHABETICS,
C     ALPHANUMERICS, INTEGERS AND REALS.
C
C     AUTHOR: MIKE PETERSON, U OF T CHEMISTRY DEPARTMENT, TORONTO.
C*
C     ARGUMENTS:
C
C     LINE: INPUT ARRAY OF ALPHABETIC CHARACTERS TO BE DECODED, STORED
C           1 CHARACTER PER ARRAY ELEMENT (IE A1 FORMAT).
C     ICOL: START DECODING AT POSITION ICOL.
C     ILAST: STOP DECODING AFTER INTERPRETING POSITION ILAST, IF NO
C            DELIMITER FOUND FIRST. ILAST SHOULD NOT BE LESS THAN ICOL.
C            ILAST IS ALSO THE LENGTH OF LINE (MAXIMUM 130 CHARACTERS).
C     ITYPE: TYPE OF CONVERSION TO BE DONE:
C            1 TO GET A FIELD OF ALPHABETIC CHARACTERS WHERE ANY
C              CHARACTER IS VALID.
C            2 TO GET A FIELD OF ALPHANUMERIC CHARACTERS WHERE ONLY
C              A TO Z, 0 TO 9, * AND THE BLANK ARE ALLOWED, WHICH MAY
C              BE PRECEEDED BY A + OR - SIGN.
C            3 TO GET ONE INTEGER VALUE, CONTAINING 8 DIGITS OR LESS,
C              EXCLUDING LEADING ZEROES AND THE SIGN.
C            4 TO GET ONE FLOATING POINT VALUE.
C            ITYPE RETURNS THE CODE FOR THE ACTUAL TYPE OF VALUE
C            RETURNED, WHICH WILL BE THE SAME AS THE INPUT VALUE,
C            UNLESS THE INPUT VALUE OF IERR IS 1 OR 2 AND THE INPUT
C            MODE IS ACTUALLY CHANGED TO ALPHABETIC OR ALPHANUMERIC.
C            IN THE LATTER CASES, ITYPE WILL BE 1 OR 2 RESPECTIVELY.
C     IDEL: ARRAY OF VALID DELIMITER CHARACTERS, ONE LEFT-JUSTIFIED
C           CHARACTER PER ELEMENT.
C     NDEL: NUMBER OF DELIMITER CHARACTERS IN IDEL (MINIMUM 1).
C     IA: ARRAY TO RETURN AN ALPHABETIC STRING, ONE CHARACTER PER
C         ELEMENT. THIS ARRAY IS BLANKED OUT TO START.
C     NIA: NUMBER OF ELEMENTS IN IA. A MAXIMUM OF NIA CHARATERS WILL BE
C         RETURNED FOR ITYPE = 1 OR 2, BUT LINE IS SEARCHED UNTIL
C         EITHER A DELIMITER IS FOUND, OR POSITION ILAST IS REACHED.
C     NCHAR: RETURNS THE ACTUAL NUMBER OF CHARACTERS IN THE STRING (0
C            IF NO CHARACTERS FOUND).
C     INTEGR: RETURNS THE VALUE OF THE INTEGER FOUND FOR ITYPE=3.
C     REALNO: RETURNS THE VALUE OF THE REAL NUMBER FOUND FOR ITYPE=4.
C     LAST: RETURNS THE LAST POSITION ACTUALLY INTERPRETED. LAST WILL
C           EQUAL ILAST IF NO NON-BLANK CHARACTERS ARE FOUND BEFORE
C           POSITION ILAST, ELSE IS THE POSITION OF THE FIRST DELIMITER.
C     ISEP: RETURNS THE SEPARATOR CHARACTER FOUND, IF THE VALUE
C           RETURNED FOR IERR IS 0 OR 1.
C     IERR: ON INPUT INDICATES THE ERROR PROCESSING OPTIONS:
C           0 TERMINATE ON ANY ERROR.
C           1 SWITCH FROM INTEGER/REAL TO ALPHABETIC INPUT IF A
C             NON-NUMERIC CHARACTER IS FOUND.
C           2 SWITCH FROM INTEGER/REAL TO ALPHANUMERIC INPUT IF A
C             NON-NUMERIC CHARACTER IS FOUND.
C           ON RETURN INDICATES A RETURN CODE:
C           0 NORMAL RETURN.
C           1 NO NON-BLANK CHARACTER FOUND BEFORE A DELIMITER (WARNING
C             ONLY).
C           2 NO NON-BLANK CHARACTER FOUND BEFORE POSITION ILAST
C             (WARNING ONLY).
C           3 DATA ITEM FOUND BUT NO SEPARATOR ENCOUNTERED BEFORE
C             POSITION ILAST (WARNING ONLY).
C          -2 AN ERROR OCCURED, A MESSAGE WAS PRINTED, LINE HAS BEEN
C             DESTROYED, AND IOP(1) SET TO -2.
C           NOTE: OF COURSE, TO SWITCH SUCCESSFULLY TO EITHER
C           ALPHABETIC OR ALPHANUMERIC INPUT, IA AND NIA MUST BE
C           DEFINED PROPERLY IN THE CALLING PROGRAM.
C*
C     GENERAL RULES:
C
C     1. LEADING BLANKS ARE ALWAYS IGNORED, AND THE FIRST OCCURANCE OF
C     ANY OF THE DELIMITER CHARACTERS AFTER A NON-BLANK CHARACTER
C     INDICATES THE END OF A DATA ITEM. PROVIDING THE BLANK IS NOT ONE
C     OF THE DELIMITERS, IMBEDDED BLANKS WILL ALSO BE IGNORED FOR
C     INTEGER/REAL INPUT, BUT NOT FOR ALPHABETIC/ALPHANUMERIC INPUT.
C
C     2. IF THE FIRST NON-BLANK CHARACTER IS A DELIMITER, OR THE ENTIRE
C     FIELD FROM ICOL TO ILAST IS BLANK, A ZERO VALUE IS RETURNED FOR
C     INTEGER/REAL INPUT, OR A NULL STRING WITH NCHAR=0 FOR ALPHABETIC
C     OR ALPHANUMERIC INPUT.
C
C     3. REAL VALUES MUST CONTAIN A DECIMAL POINT UNLESS THE ENTIRE
C     FIELD IS BLANK, AND MAY CONTAIN A D OR E EXPONENT.
C
C     4. ONLY ONE OF IA, INTEGR OR REALNO WILL ACTUALLY BE RETURNED,
C     DEPENDING ON ITYPE AND IERR.
C*
C     ICOL, ILAST, IDEL, NDEL AND NIA ARE NOT CHANGED BY THIS
C     ROUTINE. LINE IS ALTERED ONLY IF AN ERROR IS DETECTED (IERR=-2).
C     ITYPE MAY BE CHANGED ONLY IF THE INPUT VALUE OF IERR IS 1 OR 2.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA)
C##
      PARAMETER (NA= 36)
C###
      COMMON /A/ IOP(99),IC1(NA),IC2(7),C(NA,3),CD2(4),IC3(401)
C
      COMMON/IO/IN,IOUT,IODUM(215)
C*
      CHARACTER*1 LINE(ILAST), IDEL(NDEL), IA(NIA), ISEP,
     1 IBL, IDASH, IPLUS, IPOINT, ICH,
     2 IAZ(64), NUM(10)
C
      EQUIVALENCE (NUM(1),IAZ(53))
C*
      DATA IBL/' '/, IDASH/'-'/, IPLUS/'+'/, IPOINT/'.'/
      DATA IAZ/'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
     1 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
     2 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
     3 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
     4 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',
     5 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
     6 '1', '2', '3', '4', '5', '6', '7', '8', '9',
     7 '0', '*', ' '/
      DATA ZERO/0.0D0/,TEN/10.0D0/
C*
 1000 FORMAT ('0ILLEGAL CHARACTER ',A1,' FOUND AT POSITION',I3,
     1 ' OF INPUT LINE:'/'0',130A1)
 1010 FORMAT ('0REAL NUMBER DOES NOT CONTAIN A DECIMAL POINT FOR INPUT',
     1 ' LINE:'/'0',130A1)
 1020 FORMAT (1X,130A1)
 1030 FORMAT ('0INTEGER CONTAINS TOO MANY DIGITS AT POSITION',I3,
     1 ' OF INPUT LINE:'/'0',130A1)
 1040 FORMAT ('0TOO MANY DIGITS IN THE D/E EXPONENT AT POSITION',I3,
     1 ' OF INPUT LINE:'/'0',130A1)
 1050 FORMAT ('0INCOMPLETE NUMBER AT POSITION',I3,' OF INPUT LINE:'/
     1 '0',130A1)
C*
C     IF ALPHABETIC INPUT, BLANK OUT IA.
      IF (ITYPE.GE.3) GO TO 20
    1 DO 10 I=1,NIA
   10 IA(I)=IBL
      NCHAR=0
C     IGNORE LEADING BLANKS.
   20 LAST=ICOL-1
   30 IF (LAST.GE.ILAST) GO TO 50
      LAST=LAST+1
      ICH=LINE(LAST)
      IF (ICH.EQ.IBL) GO TO 30
C     CHECK FOR DELIMITERS.
      DO 40 I=1,NDEL
      IF (ICH.EQ.IDEL(I)) GO TO 45
   40 CONTINUE
      GO TO 100
C     FOUND NO CHARACTER BEFORE A DELIMITER.
   45 IERR=1
      ISEP=ICH
      GO TO 55
C     FOUND NO CHARACTERS BEFORE END-OF-FIELD.
   50 IERR=2
   55 GO TO (70,70,60,80),ITYPE
C     INTEGER.
   60 INTEGR=0
   70 RETURN
C     REAL.
   80 REALNO=ZERO
      RETURN
C     BRANCH TO CORRECT TYPE.
  100 GO TO (140,110,300,400),ITYPE
C*
C     ALPHABETIC/ALPHANUMERIC INPUT.
C*
C     CHECK THIS CHARACTER IF ONLY ALPHANUMERICS ARE ALLOWED.
  110 DO 130 I=1,64
      IF (ICH.EQ.IAZ(I)) GO TO 140
  130 CONTINUE
      IF (NCHAR.EQ.0.AND.(ICH.EQ.IPLUS.OR.ICH.EQ.IDASH)) GO TO 140
      GO TO 900
  140 IF (NCHAR.GE.NIA) GO TO 150
      NCHAR=NCHAR+1
      IA(NCHAR)=ICH
C     CONTINUE SEARCH UNTIL A DELIMITER OR END-OF-FIELD FOUND.
  150 IF (LAST.GE.ILAST) GO TO 180
      LAST=LAST+1
      ICH=LINE(LAST)
      DO 160 I=1,NDEL
      IF (ICH.EQ.IDEL(I)) GO TO 170
  160 CONTINUE
      IF (ITYPE.EQ.1) GO TO 140
      GO TO 110
C     DELIMITER FOUND.
  170 IERR=0
      ISEP=ICH
      RETURN
C     END-OF-FIELD FOUND.
  180 IERR=3
      RETURN
C*
C     INTEGER.
C*
  300 ISIGN=1
      NDIGIT=-1
      INTEGR=0
      IF (ICH.NE.IDASH) GO TO 310
C     NEGATIVE NUMBER.
      ISIGN=-1
      GO TO 350
C     TRY FOR A PLUS SIGN.
  310 IF (ICH.EQ.IPLUS) GO TO 350
C     ENSURE THIS CHARACTER IS A LEGAL DIGIT.
  320 DO 330 I=1,10
      II=I
      IF (ICH.EQ.NUM(I)) GO TO 340
  330 CONTINUE
      GO TO 900
  340 IF (NDIGIT.LT.0) NDIGIT=0
      NDIGIT=NDIGIT+1
      IF (NDIGIT.GT.8) GO TO 970
      IF (II.EQ.10) II=0
      INTEGR=10*INTEGR+II
C     IGNORE LEADING ZEROES.
      IF (INTEGR.EQ.0) NDIGIT=0
C     GET NEXT NON-BLANK CHARACTER.
  350 IF (LAST.GE.ILAST) GO TO 380
      LAST=LAST+1
      ICH=LINE(LAST)
C     CHECK FOR A DELIMITER.
      DO 360 I=1,NDEL
      IF (ICH.EQ.IDEL(I)) GO TO 370
  360 CONTINUE
      IF (ICH.EQ.IBL) GO TO 350
      GO TO 320
C     DELIMITER FOUND.
  370 ISEP=ICH
      IERR=0
      GO TO 390
C     END-OF-FIELD.
  380 IERR=3
C     END OF INPUT.
  390 IF (NDIGIT.LT.0) GO TO 990
      IF (INTEGR.GT.0.AND.ISIGN.LT.0) INTEGR=-INTEGR
      RETURN
C*
C     REAL NUMBER.
C*
  400 ISIGN=1
      REALNO=ZERO
C     INDICATE NO EXPONENT FOUND.
      IEXP=-1
C     INDICATE NO DECIMAL POINT FOUND.
      IFPT=-1
      IF (ICH.NE.IDASH) GO TO 410
C     NEGATIVE NUMBER.
      ISIGN=-1
      GO TO 500
C     TRY FOR A PLUS SIGN.
  410 IF (ICH.EQ.IPLUS) GO TO 500
C     ENSURE THIS CHARACTER IS A LEGAL DIGIT, DECIMAL POINT, D/E OR
C     EXPONENT SIGN.
  420 DO 430 I=1,10
      II=I
      IF (ICH.EQ.NUM(I)) GO TO 460
  430 CONTINUE
C     TRY FOR A DECIMAL POINT - IFPT COUNTS THE NUMBER OF DIGITS
C     AFTER THE DECIMAL POINT.
      IF (IFPT.GE.0.OR.ICH.NE.IPOINT) GO TO 440
      IFPT=0
      GO TO 500
C     TRY FOR AN EXPONENT.
  440 IF (IEXP.GE.0) GO TO 450
      IF (ICH.NE.IAZ(4) .AND. ICH.NE.IAZ(5) .AND.
     1 ICH.NE.IAZ(30) .AND. ICH.NE.IAZ(31)) GO TO 900
C     ONLY ACCEPT AN EXPONENT IF A DECIMAL POINT HAS BEEN FOUND.
      IF (IFPT.LT.0.AND.(IERR.EQ.1.OR.IERR.EQ.2)) GO TO 960
      IF (IFPT.LT.0) GO TO 930
      IEXP=0
      IEXSGN=0
      NDIGIT=0
      GO TO 500
C     TRY FOR AN EXPONENT SIGN, IF WE HAVEN'T ALREADY GOT ONE.
  450 IF (IEXSGN.NE.0) GO TO 900
      IEXSGN=1
      IF (ICH.EQ.IPLUS) GO TO 500
      IF (ICH.NE.IDASH) GO TO 900
      IEXSGN=-1
      GO TO 500
C     GOT A DIGIT - IS IT FROM THE MANTISSA OR THE EXPONENT.
  460 IF (II.EQ.10) II=0
      IF (IEXP.GE.0) GO TO 470
C     MANTISSA - INCLUDE IN SUM.
      REALNO=TEN*REALNO+DFLOAT(II)
C     IF AFTER THE DECIMAL POINT, ADD ONE TO DIGIT COUNT.
      IF (IFPT.GE.0) IFPT=IFPT+1
      GO TO 500
C     EXPONENT DIGIT.
  470 NDIGIT=NDIGIT+1
      IF (NDIGIT.GT.2) GO TO 980
      IEXP=10*IEXP+II
C     GET NEXT NON-BLANK CHARACTER.
  500 IF (LAST.GE.ILAST) GO TO 530
      LAST=LAST+1
      ICH=LINE(LAST)
C     CHECK FOR DELIMITER.
      DO 510 I=1,NDEL
      IF (ICH.EQ.IDEL(I)) GO TO 520
  510 CONTINUE
      IF (ICH.EQ.IBL) GO TO 500
      GO TO 420
C     DELIMITER FOUND.
  520 ISEP=ICH
      IERR=0
      GO TO 540
C     END-OF-FIELD FOUND.
  530 IERR=3
C     END OF INPUT - CORRECT THE MANTISSA FOR NUMBERS AFTER THE DECIMAL.
  540 IF (IFPT.LT.0) GO TO 930
      IF (REALNO.GT.ZERO.AND.ISIGN.LT.0) REALNO=-REALNO
      IF (IFPT.GT.0) REALNO=REALNO/TEN**IFPT
      IF (IEXP.LT.0) RETURN
      IF (NDIGIT.EQ.0) GO TO 990
      IF (IEXP.EQ.0) RETURN
      IF (IEXSGN.LT.0) GO TO 550
C     POSITIVE EXPONENT.
      REALNO=REALNO*TEN**IEXP
      RETURN
C     NEGATIVE EXPONENT.
  550 REALNO=REALNO/TEN**IEXP
      RETURN
C*
C     ERROR SECTION.
C*
C     ILLEGAL CHARACTER AT POSITION LAST.
  900 IF (ITYPE.GE.3.AND.(IERR.EQ.1.OR.IERR.EQ.2)) GO TO 960
      WRITE(IOUT,1000)ICH,LAST,LINE
      DO 910 I=1,ILAST
  910 LINE(I)=IBL
      LINE(LAST)=IDASH
  920 WRITE(IOUT,1020)LINE
      IERR=-2
      IOP(1)=-2
      RETURN
C     NO DECIMAL POINT, POSITIONS ICOL TO LAST.
  930 WRITE(IOUT,1010)LINE
  935 DO 940 I=1,ILAST
  940 LINE(I)=IBL
      DO 950 I=ICOL,LAST
  950 LINE(I)=IDASH
      GO TO 920
C     TRY AGAIN WITH ALPHABETIC/ALPHANUMERIC INPUT.
  960 ITYPE=IERR
      GO TO 1
C     TOO MANY INTEGER DIGITS.
  970 WRITE(IOUT,1030)LAST,LINE
      GO TO 935
C     TOO MANY EXPONENT DIGITS.
  980 WRITE(IOUT,1040)LAST,LINE
      GO TO 935
C     INCOMPLETE NUMBER.
  990 WRITE(IOUT,1050)LAST,LINE
      GO TO 935
      END
      SUBROUTINE TRED12(N,NMAX,A,Z,D,E,IEIG)
C
C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TRED2,
C     NUM. MATH. 11, 181-195(1968) BY MARTIN, REINSCH, AND WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
C     THIS SUBROUTINE IS A MODIFIED VERSION OF ARGONNE LABORATORIES
C     EISPACK SUBPROGRAM 'TRED2', AND WAS TAKEN FROM THE UNIV OF TORONTO
C     SUBROUTINE LIBRARY, WITH PERMISSION.  MODIFICATIONS TO ALLOW
C     OPTIONAL OMISSION OF THE EIGENVECTORS MADE BY M PETERSON.
C
C     THIS SUBROUTINE REDUCES A REAL SYMMETRIC MATRIX TO A
C     SYMMETRIC TRIDIAGONAL MATRIX USING AND ACCUMULATING
C     ORTHOGONAL SIMILARITY TRANSFORMATIONS.
C
C     ON INPUT:
C
C        N IS THE ORDER OF THE MATRIX;
C
C        A CONTAINS THE REAL SYMMETRIC INPUT MATRIX.  ONLY THE
C          LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED;
C
C        NMAX IS THE DECLARED DIMENSION OF A AND Z;
C
C        IEIG IS +-1 FOR JUST EIGENVALUES, +-2 FOR EIGENVECTORS ALSO.
C          IF IEIG<0, A IS NOT COPIED TO Z (A AND Z THEN MUST COINCIDE
C          OR INPUT THE MATRIX TO BE DIAGONALIZED AS MATRIX Z).
C
C        A AND Z MAY COINCIDE.  IF DISTINCT, A IS UNALTERED. TO SAVE A
C          COPY STEP, THE MATRIX MAY BE INPUT AS Z (WITH IEIG<0).
C
C     AT END OF TRED12 (BEFORE CALL TO TQL12):
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE TRIDIAGONAL MATRIX;
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
C          MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS SET TO ZERO;
C
C        Z CONTAINS THE ORTHOGONAL TRANSFORMATION MATRIX
C          PRODUCED IN THE REDUCTION (IF IEIG=+-2, ELSE Z IS DESTROYED);
C
C        ICODE HAS ABSOLUTE VALUE OF IEIG.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(NMAX,NMAX),Z(NMAX,NMAX),D(N),E(N)
C
      DATA ZERO/0.0D0/,ONE/1.0D0/
C
      IF (IEIG .LT. 0) GO TO 110
      DO 100 J = 1, N
C
      DO 100 I = J, N
  100 Z(I,J) = A(I,J)
C
  110 ICODE = IABS(IEIG)
      IF (N .EQ. 1) GO TO 320
C     *** FOR I=N STEP -1 UNTIL 2 DO -- ***
      DO 300 II = 2, N
      I = N + 2 - II
      L = I - 1
      H = ZERO
      SCALE = ZERO
      IF (L .LT. 2) GO TO 130
C     *** SCALE ROW (ALGOL TOL THEN NOT NEEDED) ***
      DO 120 K = 1, L
  120 SCALE = SCALE + DABS(Z(I,K))
C
      IF (SCALE .NE. ZERO) GO TO 140
  130 E(I) = Z(I,L)
      GO TO 290
C
  140 DO 150 K = 1, L
      F = Z(I,K) / SCALE
      Z(I,K) = F
  150 H = H + F * F
C
      G = -DSIGN(DSQRT(H),F)
      E(I) = SCALE * G
      H = H - F * G
      Z(I,L) = F - G
      F = ZERO
C
      DO 240 J = 1, L
C     *** ACTUALLY THE FOLLOWING STATEMENT NEED ONLY BE
C         EXECUTED IF EIGENVECTORS ARE NEEDED, BUT
C         MOST OFTEN ICODE IS 2, SO DO IT ANYWAYS ***
      Z(J,I) = Z(I,J) / (SCALE * H)
      G = ZERO
C     *** FORM ELEMENT OF A*U ***
      DO 180 K = 1, J
  180 G = G + Z(J,K) * Z(I,K)
C
      JP1 = J + 1
      IF (L .LT. JP1) GO TO 220
C
      DO 200 K = JP1, L
  200 G = G + Z(K,J) * Z(I,K)
C     *** FORM ELEMENT OF P ***
  220 E(J) = G / H
  240 F = F + E(J) * Z(I,J)
C
      HH = F / (H + H)
C     *** FORM REDUCED A ***
      DO 260 J = 1, L
      F = Z(I,J)
      G = E(J) - HH * F
      E(J) = G
C
      DO 260 K = 1, J
  260 Z(J,K) = Z(J,K) - F * E(K) - G * Z(I,K)
C
      DO 280 K = 1, L
  280 Z(I,K) = SCALE * Z(I,K)
C
  290 D(I) = H
  300 CONTINUE
C
  320 D(1) = ZERO
      E(1) = ZERO
C     *** ACCUMULATION OF TRANSFORMATION MATRICES ***
      IF (ICODE .NE. 2) GO TO 600
      DO 500 I = 1, N
      L = I - 1
      IF (D(I) .EQ. ZERO) GO TO 380
C
      DO 360 J = 1, L
      G = ZERO
C
      DO 340 K = 1, L
  340 G = G + Z(I,K) * Z(K,J)
C
      DO 360 K = 1, L
  360 Z(K,J) = Z(K,J) - G * Z(K,I)
C
  380 D(I) = Z(I,I)
      Z(I,I) = ONE
      IF (L .LT. 1) GO TO 500
C
      DO 400 J = 1, L
      Z(I,J) = ZERO
  400 Z(J,I) = ZERO
C
  500 CONTINUE
C
  510 CALL TQL12 (N,NMAX,Z,D,E,ICODE)
      RETURN
C     *** ALTERNATE FINAL LOOP FOR EIGENVALUES ONLY ***
  600 DO 610 I=1,N
  610 D(I) = Z(I,I)
      GO TO 510
      END
      SUBROUTINE TQL12(N,NMAX,Z,D,E,ICODE)
C
C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TQL2,
C     NUM. MATH. 11, 293-306(1968) BY BOWDLER, MARTIN, REINSCH, AND
C     WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 227-240(1971).
C     THIS SUBROUTINE IS A MODIFIED VERSION OF ARGONNE LABORATORIES
C     EISPACK SUBPROGRAM 'TQL2', AND WAS TAKEN FROM THE UNIV OF TORONTO
C     SUBROUTINE LIBRARY, WITH PERMISSION.  MODIFICATIONS TO ALLOW
C     OPTIONAL OMISSION OF THE EIGENVECTORS MADE BY M PETERSON.
C
C     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
C     OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE QL METHOD.
C     THE EIGENVECTORS OF A FULL SYMMETRIC MATRIX CAN ALSO
C     BE FOUND IF TRED12 HAS BEEN USED TO REDUCE THIS
C     FULL MATRIX TO TRIDIAGONAL FORM.
C
C     ON INPUT:
C
C        N IS THE ORDER OF THE MATRIX;
C
C        NMAX IS THE DECLARED DIMENSION OF Z;
C
C        Z CONTAINS THE TRANSFORMATION MATRIX PRODUCED IN THE
C          REDUCTION BY TRED12, IF PERFORMED.  IF THE EIGENVECTORS
C          OF A TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN
C          THE IDENTITY MATRIX;
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX;
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
C          IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY;
C
C        ICODE IS 1 FOR JUST EIGENVALUES, 2 FOR EIGENVECTORS ALSO.
C
C     ON OUTPUT:
C
C        D CONTAINS THE EIGENVALUES IN ASCENDING ORDER;
C
C        E HAS BEEN DESTROYED;
C
C        Z CONTAINS ORTHONORMAL EIGENVECTORS OF THE SYMMETRIC
C          TRIDIAGONAL (OR FULL) MATRIX.
C
C     ------------------------------------------------------------------
C
C     RELACC IS A MACHINE DEPENDENT PARAMETER SPECIFYING
C     THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA)
C##
      PARAMETER (NA= 36)
C###
      PARAMETER (ZERO=0.0D0, ONE=1.0D0, TWO=2.0D0)
C
      COMMON /A/ IOP(99),IC1(NA),IC2(7),CD1(NA,3),CD2(4),IC3(401)
C
      COMMON /IO/IN,IOUT,IODUM(215)
C
      DIMENSION Z(NMAX,NMAX),D(N),E(N)
C
      SAVE RELACC
C
      DATA RELACC/0.0D0/, PT5/0.5D0/
C
C
      IF (N .EQ. 1) RETURN
C
C     COMPUTE RELACC, THE RELATIVE MACHINE PRECISION, IF NECESSARY.
C
      IF (RELACC .EQ. ZERO) THEN
         EPS = ONE
C
   10    EPS = PT5 * EPS
         TOL1 = EPS + ONE
         IF ((TOL1.GT.ONE) .AND. (TOL1-EPS.EQ.ONE)) GO TO 10
         IF (TOL1-EPS .EQ. ONE) EPS = EPS + EPS
         RELACC = EPS
      END IF
C
      DO 100 I = 2, N
  100 E(I-1) = E(I)
C
      F = ZERO
      B = ZERO
      E(N) = ZERO
C
      DO 240 L = 1, N
      J = 0
      H = RELACC * (DABS(D(L)) + DABS(E(L)))
      IF (B .LT. H) B = H
C     *** LOOK FOR SMALL SUB-DIAGONAL ELEMENT ***
      DO 110 M = L, N
      IF (DABS(E(M)) .LE. B) GO TO 120
C     *** E(N) IS ALWAYS ZERO, SO THERE IS NO EXIT
C         THROUGH THE BOTTOM OF THE LOOP ***
  110 CONTINUE
C
  120 IF (M .EQ. L) GO TO 220
  130 IF (J .EQ. 30) GO TO 400
      J = J + 1
C     *** FORM SHIFT ***
      L1 = L + 1
      G = D(L)
      P = (D(L1) - G) / (TWO * E(L))
      R = DSQRT(P*P+ONE)
      D(L) = E(L) / (P + DSIGN(R,P))
      H = G - D(L)
C
      DO 140 I = L1, N
  140 D(I) = D(I) - H
C
      F = F + H
C     *** QL TRANSFORMATION ***
      P = D(M)
      C = ONE
      S = ZERO
      MML = M - L
C     *** FOR I=M-1 STEP -1 UNTIL L DO -- ***
      DO 200 II = 1, MML
      I = M - II
      G = C * E(I)
      H = C * P
      IF (DABS(P) .LT. DABS(E(I))) GO TO 150
      C = E(I) / P
      R = DSQRT(C*C+ONE)
      E(I+1) = S * P * R
      S = C / R
      C = ONE / R
      GO TO 160
  150 C = P / E(I)
      R = DSQRT(C*C+ONE)
      E(I+1) = S * E(I) * R
      S = ONE / R
      C = C * S
  160 P = C * D(I) - S * G
      D(I+1) = H + S * (C * G + S * D(I))
C     *** FORM VECTOR ***
      IF (ICODE .NE. 2) GO TO 200
      DO 180 K = 1, N
      H = Z(K,I+1)
      Z(K,I+1) = S * Z(K,I) + C * H
  180 Z(K,I) = C * Z(K,I) - S * H
C
  200 CONTINUE
C
      E(L) = S * P
      D(L) = C * P
      IF (DABS(E(L)) .GT. B) GO TO 130
  220 D(L) = D(L) + F
  240 CONTINUE
C     *** ORDER EIGENVALUES AND EIGENVECTORS ***
      DO 300 II = 2, N
      I = II - 1
      K = I
      P = D(I)
C
      DO 260 J = II, N
      IF (D(J) .GE. P) GO TO 260
      K = J
      P = D(J)
  260 CONTINUE
C
      IF (K .EQ. I) GO TO 300
      D(K) = D(I)
      D(I) = P
C
      IF (ICODE .NE. 2) GO TO 300
      DO 280 J = 1, N
      P = Z(J,I)
      Z(J,I) = Z(J,K)
  280 Z(J,K) = P
C
  300 CONTINUE
C
      RETURN
C     *** ERROR -- NO CONVERGENCE TO AN
C         EIGENVALUE AFTER 30 ITERATIONS ***
  400 WRITE(IOUT,1000)L
      IOP(1)=-2
      RETURN
 1000 FORMAT ('0EIGENVALUE',I6,' NOT FOUND IN 30 ITERATIONS IN ',
     1 'TRED12/TQL12.')
      END
      SUBROUTINE MATPAC(A,B,C,NX,IQ)
C*
C     --------------
C     U OF T VERSION
C     JANUARY 1987
C     --------------
C*
C     MATRIX MULTIPLICATION PACKAGE
C     SQUARE MATRICES ONLY
C     IQ=
C     1  C=A*B
C     2  C=A(TRANSPOSE)*B
C     3  C=A*B(TRANSPOSE)
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NB=#NB)
C##
      PARAMETER (NB=200)
C###
      PARAMETER (ZERO=0.0D0)
C
      DIMENSION A(NB,NB),B(NB,NB),C(NB,NB)
C*
C     BRANCH TO VARIOUS MULTIPLICATION MODES
      IF (IQ-2) 1,2,3
C*
C     C=A*B
C*
    1 DO 11 I=1,NX
      DO 11 J=1,NX
      SUM=ZERO
      DO 111 M=1,NX
  111 SUM=SUM+A(I,M)*B(M,J)
   11 C(I,J)=SUM
      RETURN
C*
C     C=A(TRANSPOSE)*B
C*
    2 DO 22 I=1,NX
      DO 22 J=1,NX
      SUM=ZERO
      DO 222 M=1,NX
  222 SUM=SUM+A(M,I)*B(M,J)
   22 C(I,J)=SUM
      RETURN
C*
C     C=A*B(TRANSPOSE)
C*
    3 DO 33 I=1,NX
      DO 33 J=1,NX
      SUM=ZERO
      DO 333 M=1,NX
  333 SUM=SUM+A(I,M)*B(J,M)
   33 C(I,J)=SUM
      RETURN
      END
      SUBROUTINE MAPRO1(A,NROWA,NCOLA,NCOLB,B,WORK)
C
C     MATRIX PRODUCT A*B WITH RESULT STORED IN A
C     A IS (NROWA,NCOLA), B IS (NCOLA,NCOLB)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NB=#NB)
C##
      PARAMETER (NB=200)
C###
      PARAMETER (ZERO=0.0D0)
C
      DIMENSION A(NB,NB),B(NB,NB),WORK(NB)
C
C
      DO 28 I = 1,NROWA
      DO 20 J = 1,NCOLB
      PROD=ZERO
      DO 16 K = 1,NCOLA
   16 PROD = PROD + A(I,K)*B(K,J)
   20 WORK(J)  = PROD
      DO 24 J = 1,NCOLB
   24 A(I,J) = WORK(J)
   28 CONTINUE
      RETURN
      END
      SUBROUTINE GBSOUT(A,EIG,MM,NN,N,INDEX)
C*
C     --------------
C     U OF T VERSION
C     JANUARY 1987
C     --------------
C*
C     GENERAL BASIS SET OUTPUT ROUTINE.  EIGENVALUES ARE PRINTED IF
C     INDEX IS EQUAL TO 1.  IF INDEX IS 2, THE ORBITAL DESIGNATIONS ARE
C     NOT PRINTED (I.E. THE MATRIX IS PRINTED BY ATOMS).
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NS=#NS)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NS=120)
C###
      COMMON /A/ IOP(99)
      COMMON /A/ NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NE,NBASIS,C(NA,3)
      COMMON /A/ CDUM(4),ICDUM(401)
C
      COMMON /BSINFO/ NVO(NA), IAOFF(NA)
      COMMON /BSINFC/ NSH(NB), LAO(NB), LABEL(NS), LSHELL(NS),
     1 BLABEL
C
      COMMON/IO/IN,IOUT,IODUM(215)
C
      CHARACTER NSH*2, LAO*4, LABEL*4, LSHELL*2,
     1 IEL*4, IBOND*4, IDUMMY*4, IELK*4, BLABEL*200
C
      DIMENSION A(MM,NN),EIG(MM),IEL(54)
C
      DATA IEL/'   H','  HE','  LI','  BE','   B','   C','   N','   O',
     1  '   F','  NE','  NA','  MG','  AL','  SI','   P','   S','  CL',
     2  '  AR','   K','  CA','  SC','  TI','   V','  CR','  MN','  FE',
     3  '  CO','  NI','  CU','  ZN','  GA','  GE','  AS','  SE','  BR',
     4  '  KR','  RB','  SR','   Y','  ZR','  NB','  MO','  TC','  RU',
     5  '  RH','  PD','  AG','  CD','  IN','  SN','  SB','  TE','   I',
     6  '  XE'/
      DATA IBOND/'  BQ'/,IDUMMY/'   X'/
C*
 1000 FORMAT (/17X,10I11)
 1001 FORMAT ('    EIGENVALUES--- ',10F11.5)
 1002 FORMAT (1X,I3,I3,A4,2X,A2,A4,10F11.5)
 1003 FORMAT (7X,I3,A4,5X,10F11.5)
 1004 FORMAT (1X)
C*
      IFLAG=1
      ILOWER=1
   10 IUPPER=ILOWER+9
      IF (IUPPER.LT.N) GO TO 20
      IUPPER=N
      IFLAG=0
   20 WRITE(IOUT,1000)(I,I=ILOWER,IUPPER)
      WRITE(IOUT,1004)
      IF (INDEX.NE.1) GO TO 30
      WRITE(IOUT,1001)(EIG(I),I=ILOWER,IUPPER)
      WRITE(IOUT,1004)
   30 I=0
      DO 90 K=1,NATOMS
      IANK=IAN(K)
      IF (INDEX.EQ.2) GO TO 60
      IF (IANK) 33,90,36
   33 IELK=IBOND
      GO TO 40
   36 IELK=IEL(IANK)
   40 NVOK=NVO(K)
      DO 50 L=1,NVOK
      I=I+1
   50 WRITE(IOUT,1002)I,K,IELK,NSH(I),LAO(I),(A(I,J),J=ILOWER,IUPPER)
      GO TO 80
   60 IF (IANK) 61,62,63
   61 IELK=IBOND
      GO TO 70
   62 IELK=IDUMMY
      GO TO 70
   63 IELK=IEL(IANK)
   70 WRITE(IOUT,1003)K,IELK,(A(K,J),J=ILOWER,IUPPER)
   80 WRITE(IOUT,1004)
   90 CONTINUE
      IF (IFLAG.EQ.0) RETURN
      ILOWER=ILOWER+10
      GO TO 10
      END
      SUBROUTINE MATOUT(X,M,N,MM,NN)
C
C     MATRIX PRINT ROUTINE
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      COMMON/IO/IN,IOUT,IODUM(215)
C
      DIMENSION X(M,N)
C
 1000 FORMAT (3X,10I12)
 1001 FORMAT ('0')
 1002 FORMAT (1X,I3,2X,10F12.6)
C
      IFLG=1
      ILOWER=1
    1 IUPPER=ILOWER+9
      IF (IUPPER-NN) 3,2,2
    2 IUPPER=NN
      IFLG=0
    3 WRITE(IOUT,1000)(J,J=ILOWER,IUPPER)
      WRITE(IOUT,1001)
      DO 4 I=1,MM
    4 WRITE(IOUT,1002)I,(X(I,J),J=ILOWER,IUPPER)
      WRITE(IOUT,1001)
      IF (IFLG.EQ.0) RETURN
      ILOWER=ILOWER+10
      GO TO 1
      END
      SUBROUTINE UPPER (Z)
C
C     CONVERT CHARACTER STRING Z TO UPPER CASE.
C
      CHARACTER Z*(*), IAZ*1
C
      DIMENSION IAZ(52)
C
      DATA IAZ/'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
     1 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
     2 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
     3 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
     4 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',
     5 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'/
C
C
C     GET LENGTH OF CHARACTER STRING Z.
C
      L = LEN(Z)
C
      DO 200 J=1,L
      DO 100 I=1,26
      IF (Z(J:J) .EQ. IAZ(I+26)) THEN
         Z(J:J) = IAZ(I)
         GO TO 200
      END IF
  100 CONTINUE
  200 CONTINUE
      RETURN
      END
