C/    GL0503B      21 MAY 90                                         MRP
      SUBROUTINE MCFOCK
C*
C     SUBROUTINE TO FORM FOCK OPERATOR IN ATOMIC ORBITAL BASIS.
C
C     ON EXIT, F CONTAINS THE FOCK MATRICES.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NF=#NF, NC=#NC, NE=2*NB)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NF=120, NC=120, NE=2*NB)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NB1=NB*(NB+1),
     1 NBP1=NB+1)
      PARAMETER (NF2=NF+2)
      PARAMETER (TWO=2.0D0)
C
      COMMON /A/ IOP(99)
      COMMON /A/ NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NED,NBASIS,C(NA,3)
      COMMON /A/ DUMC(4),IDUMC(401)
C
      COMMON/SCF1/ACURCY,F(NB1)
      COMMON/SCF2/COUL(NB1)
      COMMON/SCF3/A(NF,NF2),H(NBB)
      COMMON/SCF4/EIG(NE),RN(NF),OCC(9),ALP(55),BETA(55),DUM4(NC),
     1 OCCA(9),OCCB(9),
     2 ICONF(NC),IRHF,NCONF,NCORE,NVAL,NOPEN,NFOCK,IMO(4),ILIM(NBP1),
     3 LLIM(NBB)
C
      COMMON/IO/IODUM1(5),IMOINT,IFILE,JFILE,ILABEL,ICOUPL,IFORMT,
     1 IODUM2(206)
C
      DIMENSION EXCH(NB1), FILL3(NB1)
C
      EQUIVALENCE (COUL(1),EXCH(1)), (FILL3(1),A(1,1))
C
      NN=(NBASIS+1)*NBASIS/2
C     READ IN H-MATRIX AND VECTOR COUPLING CONSTANTS
      CALL TREAD(13,H,NBB,1,NN,1,0)
      CALL TREAD(17,A,NF,NF2,NFOCK,NFOCK+2,0)
      NMAX=NN*NFOCK
      READ(IFILE) (COUL(I),I=1,NMAX)
      JJ=0
      DO 30 I=1,NBASIS
      DO 30 J=1,I
      JJ=JJ+1
      IJ=LLIM(JJ)
      DO 30 K=1,NFOCK
      II=IJ+K
C     HCORE PART.
      F(II)=RN(K)*H(JJ)
C     COULOMB PART
      DO 10 L=1,K
      IF(L.EQ.K) GO TO 10
      KK=IJ+L
      F(II)=F(II)+A(K,L)*COUL(KK)
   10 CONTINUE
      KK=IJ+K
      F(II)=F(II)+TWO*A(K,K)*COUL(KK)
      IF(K.EQ.NFOCK) GO TO 30
      K1=K+1
      DO 20 L=K1,NFOCK
      KK=IJ+L
   20 F(II)=F(II)+A(L,K)*COUL(KK)
   30 CONTINUE
C     EXCHANGE PART
      READ(IFILE) (EXCH(I),I=1,NMAX)
      REWIND IFILE
      JJ=0
      DO 60 I=1,NBASIS
      DO 60 J=1,I
      JJ=JJ+1
      IJ=LLIM(JJ)
      DO 60 K=1,NFOCK
      II=IJ+K
      DO 40 L=1,K
      IF(L.EQ.K) GO TO 40
      KK=IJ+L
      F(II)=F(II)+A(L,K)*EXCH(KK)
   40 CONTINUE
      KK=IJ+K
      F(II)=F(II)-A(K,K)*EXCH(KK)
      IF(K.EQ.NFOCK) GO TO 60
      K1=K+1
      DO 50 L=K1,NFOCK
      KK=IJ+L
   50 F(II)=F(II)+A(K,L)*EXCH(KK)
   60 CONTINUE
C
C     WRITE UNPERTURBED FOCK MATRIX TO JFILE.
C
      REWIND JFILE
      WRITE(JFILE) (F(I),I=1,NMAX)
C
C     CHECK FOR THE PRESENCE OF A FIELD (EXTERNAL OR SCRFT),
C     THEN WRITE PERTURBED FOCK MATRIX TO JFILE.
C
      IF (IOP(3) .NE. 0) THEN
         CALL RSCRFT (F, COUL)
         WRITE(JFILE) (F(I),I=1,NMAX)
      END IF
C
      ENDFILE JFILE
      REWIND JFILE
      RETURN
      END
      SUBROUTINE PAIRS(IEND,DCONV)
C*
C     ON ENTRY, F CONTAINS THE FOCK MATRICES.
C
C     ON EXIT, C CONTAINS THE COEFFICIENT CORRECTIONS.
C     IEND RETURNS A CONVERGENCE CODE: 0 IF COEFFICIENTS ARE CONVERGED,
C     -1 IF THE INDIVIDUAL COEFFICIENTS ARE NOT CONVERGED BUT THE RMS
C     AVERAGE OF THE COEFFICIENTS IS CONVERGED, AND A POSITIVE VALUE
C     RETURNS THE NUMBER OF NON-CONVERGED COEFFICIENTS.
C     DCONV RETURNS THE RMS COEFFICIENT CORRECTION.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NF=#NF, NC=#NC, NE=2*NB)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NF=120, NC=120, NE=2*NB)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NB1=NB*(NB+1),
     1 NBP1=NB+1)
      PARAMETER (NF2=NF+2)
      PARAMETER (ZERO=0.0D0, ONE=1.0D0, TWO=2.0D0)
C
      COMMON /A/ IOP(99),
     1 NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NED,NBASIS,CO(NA,3),
     2 DUMC(4),IDUMC(401)
C
      COMMON/SCF1/ACURCY,F(NB1)
      COMMON/SCF2/U(NB,NB),DUM2(NB)
      COMMON/SCF3/C(NB,NB),DUM3(NB)
      COMMON/SCF4/RD1(NE),RD2(NF),RD3(NC),RD4(137),
     1 ICONF(NC),IRHF,NCONF,NCORE,NVAL,NOPEN,
     2 NFOCK,ID1(4),ID2(NBP1),LLIM(NBB)
C
      COMMON/IO/IN,IOUT,IODUM1(3),
     1 IMOINT,IFILE,JFILE,ILABEL,ICOUPL,IFORMT,IODUM2(206)
C
      DIMENSION FJK(NB1),A(NF,NF2),E(NB,NB)
C
      EQUIVALENCE (F(1),E(1,1)),(U(1,1),A(1,1)),(C(1,1),FJK(1))
C
      DATA THREE,FOUR,PT5/3.0D0,4.0D0,0.5D0/
      DATA TENM7/1.0D-7/,FIVM5/5.0D-5/,TEN/10.0D0/
C
 1000 FORMAT (/'0COEFFICIENT CORRECTIONS (END OF ROUTINE PAIRS)')
C
      THRES=FIVM5
      IF(IOP(25).NE.0)THRES=TEN**(-IOP(25))
      DCONV=ZERO
      NN=NBASIS*(NBASIS+1)/2
      NOCC=NCORE+NVAL+NOPEN
      NMAX=NN*NFOCK
      NOCC1=NOCC+1
      CALL TREAD(25,U,NB,NB,NBASIS,NBASIS,0)
C     CALCULATE ZERO-TH ORDER MATRIX
      ICORE=1-NCORE
      DO 1 J=1,NBASIS
      DO 1 I=1,NBASIS
    1 C(I,J)=ZERO
      NCP=NCORE+1
      NCP1=NCP+1
      IF(NCORE.EQ.0) GO TO 30
      IF(NCORE.EQ.NOCC)GO TO 13
      DO 11 I=NCP,NOCC
      IFIX=I+ICORE
      DO 11 J=1,NCORE
      ALPHA=ZERO
      BETA=ZERO
      MM=0
      DO 12 M1=1,NBASIS
      FMN=TWO
      DO 12 N1=1,M1
      IF(N1.EQ.M1)FMN=ONE
      MM=MM+1
      DA=U(M1,I)*U(N1,J)+U(N1,I)*U(M1,J)
      DB=U(M1,I)*U(N1,I)
      DC=U(M1,J)*U(N1,J)
      II=LLIM(MM)+IFIX
      JJ=LLIM(MM)+1
      FF=F(JJ)-F(II)
      ALPHA=ALPHA+FMN*DA*FF
   12 BETA=BETA+FMN*(DB-DC)*FF
      C(I,J)=ALPHA*PT5
   11 C(J,I)=BETA
   13 IF(NOCC.GE.NBASIS) GO TO 30
C     CORE-VIRTUAL
      DO 21 I=NOCC1,NBASIS
      DO 21 J=1,NCORE
      ALPHA=ZERO
      BETA=ZERO
      MM=0
      DO 22 M1=1,NBASIS
      FMN=TWO
      DO 22 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,I)*U(N1,J)+U(N1,I)*U(M1,J)
      DB=U(M1,I)*U(N1,I)
      DC=U(M1,J)*U(N1,J)
      JJ=LLIM(MM)+1
      ALPHA=ALPHA+FMN*DA*F(JJ)
   22 BETA=BETA+FMN*(DB-DC)*F(JJ)
      C(I,J)=ALPHA*PT5
   21 C(J,I)=BETA
C     VALENCE-VALENCE
   30 IF(NCP1.GT.NOCC)GO TO 33
      DO 31 I=NCP1,NOCC
      IFIX=I+ICORE
      I1=I-1
      DO 31 J=NCP,I1
      JFIX=J+ICORE
      ALPHA=ZERO
      BETA=ZERO
      MM=0
      DO 32 M1=1,NBASIS
      FMN=TWO
      DO 32 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,I)*U(N1,J)+U(N1,I)*U(M1,J)
      DB=U(M1,I)*U(N1,I)
      DC=U(M1,J)*U(N1,J)
      II=LLIM(MM)+IFIX
      JJ=LLIM(MM)+JFIX
      FF=F(JJ)-F(II)
      ALPHA=ALPHA+FMN*DA*FF
   32 BETA=BETA+FMN*(DB-DC)*FF
      C(I,J)=ALPHA*PT5
   31 C(J,I)=BETA
   33 IF(NOCC.GE.NBASIS.OR.NCORE.EQ.NOCC)GO TO 50
C     VALENCE-VIRTUAL
      DO 41 I=NOCC1,NBASIS
      DO 41 J=NCP,NOCC
      JFIX=J+ICORE
      ALPHA=ZERO
      BETA=ZERO
      MM=0
      DO 42 M1=1,NBASIS
      FMN=TWO
      DO 42 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,I)*U(N1,J)+U(N1,I)*U(M1,J)
      DB=U(M1,I)*U(N1,I)
      DC=U(M1,J)*U(N1,J)
      JJ=LLIM(MM)+JFIX
      ALPHA=ALPHA+FMN*DA*F(JJ)
   42 BETA=BETA+FMN*(DB-DC)*F(JJ)
      C(I,J)=ALPHA*PT5
   41 C(J,I)=BETA
C     TEST OF CONVERGENCE
   50 IEND=0
      IF(NBASIS.EQ.1)RETURN
      DO 51 I=2,NBASIS
      I1=I-1
      DO 51 J=1,I1
      CIJ=DABS(C(I,J))
      DCONV=DCONV+CIJ*CIJ
      IF(CIJ.LT.TENM7)C(I,J)=ZERO
   51 IF(CIJ.GE.THRES) IEND=IEND+1
      DCONV=DSQRT(DCONV/DFLOAT(NN-NBASIS))
      IF(IEND.EQ.0)RETURN
      IF(DCONV.LT.THRES)IEND=-1
C     CALCULATE THE HIGHER ORDER CORRECTIONS - FIRST SAVE C
C     TEMPORARILY IN FILE 27.
      CALL TWRITE(27,C,NB,NB,NBASIS,NBASIS,0)
C     COULOMB INTEGRALS
      READ(IFILE) (FJK(I),I=1,NMAX)
      DO 101 J=1,NBASIS
      DO 101 I=1,NBASIS
  101 E(I,J)=ZERO
      IF(NCORE.EQ.0.OR.NCORE.EQ.NOCC)GO TO 120
      DO 111 I=NCP,NOCC
      IFIX=I+ICORE
      DO 111 J=1,NCORE
      SUM=ZERO
      MM=0
      DO 112 M1=1,NBASIS
      FMN=TWO
      DO 112 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,J)*U(N1,J)
      II=LLIM(MM)+IFIX
  112 SUM=SUM+FMN*DA*FJK(II)
  111 E(I,J)=SUM
C     VALENCE-VALENCE
  120 IF(NCP1.GT.NOCC)GO TO 123
      DO 121 I=NCP1,NOCC
      IFIX=I+ICORE
      I1=I-1
      DO 121 J=NCP,I1
      SUM=ZERO
      MM=0
      DO 122 M1=1,NBASIS
      FMN=TWO
      DO 122 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,J)*U(N1,J)
      II=LLIM(MM)+IFIX
  122 SUM=SUM+FMN*DA*FJK(II)
  121 E(I,J)=SUM
  123 IF(NOCC.GE.NBASIS.OR.NCORE.EQ.NOCC)GO TO 140
C     VALENCE-VIRTUAL
      DO 131 I=NOCC1,NBASIS
      DO 131 J=NCP,NOCC
      JFIX=J+ICORE
      SUM=ZERO
      MM=0
      DO 132 M1=1,NBASIS
      FMN=TWO
      DO 132 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,I)*U(N1,I)
      JJ=LLIM(MM)+JFIX
  132 SUM=SUM+FMN*DA*FJK(JJ)
  131 E(I,J)=SUM
C     EXCHANGE INTEGRAL
  140 READ(IFILE) (FJK(I),I=1,NMAX)
      REWIND IFILE
      IF(NCORE.EQ.0.OR.NCORE.EQ.NOCC)GO TO 220
      DO 211 I=NCP,NOCC
      IFIX=I+ICORE
      DO 211 J=1,NCORE
      SUM=ZERO
      MM=0
      DO 212 M1=1,NBASIS
      FMN=TWO
      DO 212 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,J)*U(N1,J)
      II=LLIM(MM)+IFIX
  212 SUM=SUM+FMN*DA*FJK(II)
  211 E(J,I)=SUM
C     VALENCE-VALENCE
  220 IF(NCP1.GT.NOCC)GO TO 223
      DO 221 I=NCP1,NOCC
      IFIX=I+ICORE
      I1=I-1
      DO 221 J=NCP,I1
      SUM=ZERO
      MM=0
      DO 222 M1=1,NBASIS
      FMN=TWO
      DO 222 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,J)*U(N1,J)
      II=LLIM(MM)+IFIX
  222 SUM=SUM+FMN*DA*FJK(II)
  221 E(J,I)=SUM
  223 IF(NOCC.GE.NBASIS.OR.NCORE.EQ.NOCC)GO TO 240
C     VALENCE-VIRTUAL
      DO 231 I=NOCC1,NBASIS
      DO 231 J=NCP,NOCC
      JFIX=J+ICORE
      SUM=ZERO
      MM=0
      DO 232 M1=1,NBASIS
      FMN=TWO
      DO 232 N1=1,M1
      MM=MM+1
      IF(N1.EQ.M1)FMN=ONE
      DA=U(M1,I)*U(N1,I)
      JJ=LLIM(MM)+JFIX
  232 SUM=SUM+FMN*DA*FJK(JJ)
  231 E(J,I)=SUM
C     CORRECTION MATRIX
C     READ IN VECTOR COUPLING CONSTANTS
  240 CALL TREAD(17,A,NF,NF2,NFOCK,NFOCK+2,0)
C     RESTORE MATRIX C FROM FILE 27.
      CALL TREAD(27,C,NB,NB,NBASIS,NBASIS,0)
      IF(NCORE.EQ.0.OR.NCORE.EQ.NOCC)GO TO 320
C     CORE-VALENCE
      DO 311 I=NCP,NOCC
      IFIX=I+ICORE
      DO 311 J=1,NCORE
      TUM=FOUR*(A(IFIX,IFIX)+ONE-A(IFIX,1))*E(J,I)
     1 -(A(IFIX,IFIX)+ONE+TWO*A(1,IFIX))*(E(I,J)+E(J,I))
  311 C(J,I)=C(J,I)+TUM
C     VALENCE-VALENCE
  320 IF(NCP1.GT.NOCC)GO TO 322
      DO 321 I=NCP1,NOCC
      IFIX=I+ICORE
      I1=I-1
      DO 321 J=NCP,I1
      JFIX=J+ICORE
      TUM=FOUR*(A(IFIX,IFIX)+A(JFIX,JFIX)-A(IFIX,JFIX))*E(J,I)
     1 -(A(IFIX,IFIX)+A(JFIX,JFIX)+TWO*A(JFIX,IFIX))*(E(I,J)+E(J,I))
  321 C(J,I)=C(J,I)+TUM
  322 IF(NOCC.GE.NBASIS.OR.NCORE.EQ.NOCC)RETURN
C     VALENCE-VIRTUAL
      DO 331 I=NOCC1,NBASIS
      DO 331 J=NCP,NOCC
      JFIX=J+ICORE
      TUM=A(JFIX,JFIX)*(THREE*E(J,I)-E(I,J))
  331 C(J,I)=C(J,I)+TUM
C
      IF (IOP(31) .LE. 5) RETURN
      WRITE (IOUT,1000)
      CALL GBSOUT (C, DUM3, NB, NB, NBASIS, 0)
      RETURN
      END
      SUBROUTINE ROTSCF(SCALE,ICUT,FACTDN,SLIMDN)
C*
C     TWO-BY-TWO ROTATION BY HINZE.
C     CALCULATE ( I I FK I J )
C
C     SUBROUTINE ARGUMENTS:
C     SCALE  - CURRENT VALUE OF THE SCALE FACTOR (MAY BE CUT BY ROTSCF).
C     ICUT   - NUMBER OF SCALE FACTOR CUTS IN ROTSCF.
C     FACTDN - FACTOR TO MULTIPLY WITH SCALE TO GET THE NEXT SCALE
C              FACTOR TO BE USED.
C     SLIMDN - LOWER LIMIT ON THE SCALE FACTOR.
C
C     ON ENTRY, C CONTAINS THE COEFFICIENT CORRECTIONS.
C     ON EXIT, U CONTAINS THE ROTATED COEFFICIENTS.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NF=#NF, NC=#NC, NE=2*NB)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NF=120, NC=120, NE=2*NB)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NBP1=NB+1)
      PARAMETER (NF2=NF+2)
      PARAMETER (ONE=1.0D0, TWO=2.0D0)
C
      COMMON /A/ IOP(99),
     1 NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NED,NBASIS,CO(NA,3),
     2 DUMC(4),IDUMC(401)
C
      COMMON/SCF1/ACURCY,S(NB,NB),SS(NB)
      COMMON/SCF2/U(NB,NB),DUM2(NB)
      COMMON/SCF3/C(NB,NB),DUM3(NB)
      COMMON/SCF4/RD1(NE),RD2(NF),RD3(NC),RD4(137),
     1 ID1(NC),IRHF,NCONF,NCORE,NVAL,NOPEN,NFOCK,IMO(4),
     2 ID2(NBP1),ID3(NBB)
C
      COMMON/IO/IN,IOUT,IODUM(215)
C
      DATA PT5/0.5D0/, THRES/1.0D-6/
C
 1000 FORMAT(' ** WARNING **  SIN =',1PD13.5,' - CONTINUED WITH ',
     1 'NO ROTATION AT I =',I4,' J =',I4,' IN ROTSCF')
 1010 FORMAT (/'0COEFFICIENTS FROM DISK (START OF ROTSCF)')
 1020 FORMAT (/'0COEFFICIENTS BEFORE ORTHOGONALIZATION (END OF ROTSCF)')
C
      SR2B2=DSQRT(PT5)
      NOCC=NCORE+NOPEN+NVAL
      NOCC1=NOCC+1
      NFERM=IMO(2)-1
      NCP=NCORE + 1
      NCP1=NCP+1
      ILAST=NFERM
      IF(IOP(26).EQ.0) ILAST=NOCC
      GO TO 110
C
C     TRY ROTATIONS AGAIN WITH A SMALLER SCALE.
C
  100 SCALE = FACTDN * SCALE
      ICUT=ICUT+1
C
  110 CALL TREAD(25,U,NB,NB,NBASIS,NBASIS,0)
      IF (IOP(31) .NE. 7) GO TO 115
      WRITE (IOUT,1010)
      CALL GBSOUT (U, DUM2, NB, NB, NBASIS, 0)
C
C     CHECK FOR TOO MANY SCALE FACTOR CUTS.
C
  115 IF (SCALE .LT. SLIMDN) GO TO 300
C     BETWEEN CORE AND VALENCE ORBITALS.
      IF(NCORE.EQ.ILAST.OR.NCORE.EQ.0)GO TO 130
      DO 120 I=NCP,ILAST
      DO 120 J=1,NCORE
      ALPHA=TWO*C(I,J)
      BETA=C(J,I)
      IF(ALPHA) 121,120,122
  121 SGS = -ONE
      GO TO 123
  122 SGS = ONE
  123 IF(DABS(ALPHA).LE.THRES.OR.DABS(BETA).LE.THRES)GO TO 120
      ALPHA=SCALE*ALPHA/BETA
      SINF=SGS*DSQRT(ONE-ONE/DSQRT(ONE+ALPHA*ALPHA))
      IF(DABS(SINF).LT.SR2B2) GO TO 124
      IF(IOP(29).NE.3)GO TO 100
      WRITE(IOUT,1000) SINF,I,J
      GO TO 120
  124 COSF=DSQRT(ONE-SINF*SINF)
      DO 125 IB=1,NBASIS
      TEMP=U(IB,I)*COSF+U(IB,J)*SINF
      U(IB,J) = U(IB,J)*COSF-U(IB,I)*SINF
  125 U(IB,I)=TEMP
  120 CONTINUE
C     BETWEEN VALENCE ORBITALS.
  130 IF(NCP1.GT.ILAST)GO TO 160
      DO 150 I=NCP1,ILAST
      I1=I-1
      DO 150 J=NCP,I1
      ALPHA=TWO*C(I,J)
      BETA=C(J,I)
      IF(ALPHA) 151,150,152
  151 SGS=-ONE
      GO TO 153
  152 SGS=ONE
  153 IF(DABS(ALPHA).LE.THRES.OR.DABS(BETA).LE.THRES)GO TO 150
      ALPHA=SCALE*ALPHA/BETA
      SINF=SGS*DSQRT(ONE-ONE/DSQRT(ONE+ALPHA*ALPHA))
      IF(DABS(SINF).LT.SR2B2) GO TO 154
      IF(IOP(29).NE.3)GO TO 100
      WRITE(IOUT,1000) SINF,I,J
      GO TO 150
  154 COSF=DSQRT(ONE-SINF*SINF)
      DO 155 IB=1,NBASIS
      TEMP=U(IB,I)*COSF + U(IB,J)*SINF
      U(IB,J) = U(IB,J)*COSF-U(IB,I)*SINF
  155 U(IB,I)=TEMP
  150 CONTINUE
  160 IF(IOP(26).EQ.0) GO TO 230
C     BETWEEN VALENCE ORBITALS
      ISTAT=NFERM+1
      ISTAT1=ISTAT+1
      IF(ISTAT1.GT.NOCC)GO TO 230
      DO 220 I=ISTAT1,NOCC
      I1=I-1
      DO 220 J=ISTAT,I1
      ALPHA=TWO*C(I,J)
      BETA=C(J,I)
      IF(ALPHA) 221,220,222
  221 SGS=-ONE
      GO TO 223
  222 SGS= ONE
  223 IF(DABS(ALPHA).LE.THRES.OR.DABS(BETA).LE.THRES)GO TO 220
      ALPHA=SCALE*ALPHA/BETA
      SINF=SGS*DSQRT(ONE-ONE/DSQRT(ONE+ALPHA*ALPHA))
      IF(DABS(SINF).LT.SR2B2) GO TO 224
      IF(IOP(29).NE.3)GO TO 100
      WRITE(IOUT,1000) SINF,I,J
      GO TO 220
  224 COSF=DSQRT(ONE-SINF*SINF)
      DO 225 IB=1,NBASIS
      TEMP=U(IB,I)*COSF+U(IB,J)*SINF
      U(IB,J)=U(IB,J)*COSF-U(IB,I)*SINF
  225 U(IB,I)=TEMP
  220 CONTINUE
  230 IF(NOCC.EQ.NBASIS) GO TO 258
      JSTAT=NFERM+1
      IF(IOP(26).EQ.0) JSTAT=NCP
      IF(JSTAT.GT.NOCC)GO TO 260
C     BETWEEN VALENCE AND VIRTUAL ORBITAL
      DO 250 I=NOCC1,NBASIS
      DO 250 J=JSTAT,NOCC
      ALPHA=TWO*C(I,J)
      BETA=C(J,I)
      IF(ALPHA) 251,250,252
  251 SGS = -ONE
      GO TO 253
  252 SGS= ONE
  253 IF(DABS(ALPHA).LE.THRES.OR.DABS(BETA).LE.THRES)GO TO 250
      ALPHA=SCALE*ALPHA/BETA
      SINF=SGS*DSQRT(ONE-ONE/DSQRT(ONE+ALPHA*ALPHA))
      IF(DABS(SINF).LT.SR2B2) GO TO 254
      IF(IOP(29).NE.3)GO TO 100
      WRITE(IOUT,1000) SINF,I,J
      GO TO 250
  254 COSF=DSQRT(ONE-SINF*SINF)
      DO 255 IB=1,NBASIS
      TEMP=U(IB,J)*COSF - U(IB,I)*SINF
      U(IB,I)= U(IB,I)*COSF + U(IB,J)*SINF
  255 U(IB,J)=TEMP
  250 CONTINUE
  260 IF(IOP(26).NE.0) GO TO 258
      IF(NCORE.EQ.0) GO TO 258
C     BETWEEN CORE AND VIRTUAL ORBITALS
      DO 280 I=NOCC1,NBASIS
      DO 280 J=1,NCORE
      ALPHA=TWO*C(I,J)
      BETA=C(J,I)
      IF(ALPHA) 281,280,282
  281 SGS=-ONE
      GO TO 283
  282 SGS=ONE
  283 IF(DABS(ALPHA).LE.THRES.OR.DABS(BETA).LE.THRES)GO TO 280
      ALPHA=SCALE*ALPHA/BETA
      SINF=SGS*DSQRT(ONE-ONE/DSQRT(ONE+ALPHA*ALPHA))
      IF(DABS(SINF).LT.SR2B2) GO TO 284
      IF(IOP(29).NE.3)GO TO 100
      WRITE(IOUT,1000) SINF,I,J
      GO TO 280
  284 COSF=DSQRT(ONE-SINF*SINF)
      DO 285 IB=1,NBASIS
      TEMP=U(IB,J)*COSF-U(IB,I)*SINF
      U(IB,I)=U(IB,I)*COSF+U(IB,J)*SINF
  285 U(IB,J)=TEMP
  280 CONTINUE
C
C     SCHMIDT ORTHOGONALIZATION
C
  258 IF (IOP(31) .LE. 5) GO TO 290
      WRITE (IOUT,1020)
      CALL GBSOUT (U, DUM4, NB, NB, NBASIS, 0)
C
  290 CALL SCHMDT(U,S,NBASIS)
  300 CALL TWRITE(27,U,NB,NB,NBASIS,NBASIS,0)
      RETURN
      END
      SUBROUTINE CONRHF(ITYPE,MOLX,IEXT,LABEL,CCONV,MATCH)
C*
C     --------------
C     U OF T VERSION
C     DECEMBER 1988
C     --------------
C*
C     RHF SCF/CI CONVERGENCE ROUTINES:
C     RHF (ITYPE=0): USES DISK FILES 31, 32 AND 33 FOR SCRATCH.
C     CI (ITYPE=1): USES DISK FILES 4, 40 AND 42 FOR SCRATCH.
C     EACH MAXIMUM OF #NB*#NR DOUBLE WORDS LONG.
C     ON RETURN, IEXT IS -1 IF C HAS JUST BEEN EXTRAPOLATED, 0 FOR NO
C     EXTRAPOLATION, 1 FOR THE FIRST ITERATION AFTER EXTRAPOLATION.
C     ON RETURN, MATCH IS NORMALLY TRUE, BUT IS SET FALSE IF THE
C     MO SYMMETRY MATCHING FAILED.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NR=#NR)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NR=101)
C###
      PARAMETER (NBP1=NB+1)
      PARAMETER (ZERO=0.0D0, ONE=1.0D0, TWO=2.0D0)
C
      COMMON /A/ IOP(99)
      COMMON /A/ IC1(NA),IC2(6),NBASIS,CD1(NA,3),CD2(4),IC3(401)
C
      COMMON/SCF1/ACURCY,A1(NB,NBP1)
      COMMON/SCF2/A2(NB,NBP1)
      COMMON/SCF3/A3(NB,NBP1)
C
      LOGICAL MATCH
C
      CHARACTER*8 LABEL
C
      SAVE
C
      DATA PT99/0.99D0/, PT995/0.995D0/, ONEPT9/1.9D0/
      DATA FOUR/4.0D0/, PT06/0.06D0/
C
      IEXT=1
      LABEL = ' '
      MATCH = .TRUE.
C     SWITCH SCRATCH FILE DEFINITIONS.
      IF(ITYPE.EQ.1)GO TO 10
C     SCF ENTRY.
      LOC=31
      LOC1=LOCSCF
      LOC2=65-LOC1
      LOCSCF=LOC2
      ICOUNT=ICSCF
      IDEWIT=IDWSCF
      IEXTRP=IOP(17)+1
      GO TO 20
C     CI ENTRY.
   10 LOC=4
      LOC1=LOCCI
      LOC2=82-LOC1
      LOCCI=LOC2
      ICOUNT=ICCI
      IDEWIT=IDWCI
      IEXTRP=IOP(23)+1
   20 ICOUNT=ICOUNT+1
C     GET CURRENT MO.
      CALL TREAD(25,A3,NB,NB,NBASIS,NBASIS,0)
      IF(ICOUNT.EQ.1)GO TO 910
      IEXT=0
C     GET PREVIOUS MO.
      CALL TREAD(LOC,A1,NB,NR,NBASIS,MOLX,0)
      CALL CSD(MOLX,LABEL,MATCH)
C     FAILURE IN CSD.
      IF(MATCH)GO TO 50
      IDEWIT=0
      CCONV=ZERO
      GO TO 900
   50 CALL TWRITE(25,A3,NB,NB,NBASIS,NBASIS,0)
      CALL TREAD(LOC,A1,NB,NR,NBASIS,MOLX,0)
C     GET DIFFERENCE OF CURRENT AND PREVIOUS COEFFICIENTS.
      DO 60 J=1,MOLX
      DO 60 I=1,NBASIS
   60 A2(I,J)=A3(I,J)-A1(I,J)
C     FIND LENGTH DP1.
      SP11=TRARHF(A2,A2,NBASIS,MOLX)
      DP1=DSQRT(SP11)
      CCONV=DP1/DSQRT(DFLOAT(NBASIS*MOLX))
C     WHAT TYPE OF EXTRAPOLATION?
      GO TO (100,300,100,900),IEXTRP
C     POPLE EXTRAPOLATION.
  100 IF(ICOUNT.LE.2)GO TO 240
      IF(ICOUNT.EQ.3)GO TO 110
      CALL TREAD(LOC1,A1,NB,NR,NBASIS,MOLX,0)
      SP23=SP12
      SP33=SP22
      SP13=TRARHF(A1,A2,NBASIS,MOLX)
C     FIND LENGTH DP3.
      DP3=DSQRT(SP33)
C     READ C(N-1)-C(N-2) INTO A1.
  110 CALL TREAD(LOC2,A1,NB,NR,NBASIS,MOLX,0)
      SP12=TRARHF(A1,A2,NBASIS,MOLX)
      SP22=TRARHF(A1,A1,NBASIS,MOLX)
C     FIND LENGTH DP2.
      DP2=DSQRT(SP22)
      IF(ICOUNT.EQ.3)GO TO 240
      IF(SP11.EQ.ZERO.OR.SP22.EQ.ZERO.OR.SP33.EQ.ZERO)GO TO 240
C     FIND COSINE OF ANGLE BETWEEN SUCCESSIVE DISPLACEMENTS.
      COSPHI=SP12/(DP1*DP2)
C     FIND COSINE OF ANGLE BETWEEN DP(3) AND PLANE OF DP(1) AND DP(2).
      X=(SP13*SP22-SP12*SP23)/(SP11*SP22-SP12*SP12)
      Y=(SP23*SP11-SP12*SP13)/(SP11*SP22-SP12*SP12)
      COSPSI=DSQRT(X*X*SP11+Y*Y*SP22+TWO*X*Y*SP12)/DP3
C     DO NOT EXTRAPOLATE UNLESS 4 CONSECUTIVE POINTS ARE NEARLY COPLANAR
      IF(COSPSI.LE.PT99)GO TO 240
C     EXPRESS DP(1) AS X*DP(3)(PROJECTED)+Y*DP(2).
      Y=-Y/X
      X=ONE/X
C     TEST IF 2*2 MATRIX HAS REAL EIGENVALUES BETWEEN -.95 AND +.95
      XY=Y*Y+FOUR*X
      IF(XY.LT.ZERO)GO TO 190
      XY=DABS(Y)+DSQRT(XY)
      IF(XY.LE.ONEPT9)GO TO 220
  190 IF(IOP(18).EQ.1)GO TO 240
C     IF 4-POINT EXTRAPOLATION IS NOT POSSIBLE TRY 3-POINT.
      IF(DABS(COSPHI).LE.PT995)GO TO 240
      X=DP1/(DP2*COSPHI-DP1)
      DO 210 J=1,MOLX
      DO 210 I=1,NBASIS
  210 A3(I,J)=A3(I,J)+X*A2(I,J)
      LABEL = '3-POINT'
      ICOUNT=0
      IEXT=-1
      CALL SCHMDT(A3,A1,NBASIS)
      GO TO 920
  220 XXX=X/(ONE-X-Y)
      YYY=(X+Y)/(ONE-X-Y)
      DO 230 J=1,MOLX
      DO 230 I=1,NBASIS
  230 A3(I,J)=A3(I,J)+XXX*A1(I,J)+YYY*A2(I,J)
      LABEL = '4-POINT'
      ICOUNT=0
      IEXT=-1
      CALL SCHMDT(A3,A2,NBASIS)
      GO TO 920
C     SAVE CURRENT DIFFERENCE.
  240 CALL TWRITE(LOC1,A2,NB,NR,NBASIS,MOLX,0)
      GO TO 910
C     DEWAR EXTRAPOLATION. MJS DEWAR AND PK WEINER, COMP & CHEM, 2,
C     31 (1978). CALCULATE A NEW VALUE FOR LAMBDA AND SAVE PREVIOUS
C     VALUE IN Y2.
  300 IDEWIT=IDEWIT+1
C     IDEWIT CONTROLS THE EXTRAPOLATION PROCEDURE:
C     1 ... JUST EXTRAPOLATED THE DENSITY MATRIX,
C     2 ... CALCULATE LAMBDA2,
C     3 ... CALCULATE LAMBDA3 AND EXTRAPOLATE.
      IF(IDEWIT-2)240,305,303
  303 Y2=Y
  305 CALL TREAD(LOC2,A1,NB,NR,NBASIS,MOLX,0)
      SP22=TRARHF(A1,A1,NBASIS,MOLX)
      SP12=TRARHF(A1,A2,NBASIS,MOLX)
      Y=SP12/SP22
C     CHECK FOR DIVERGENCE.
      IF(DABS(Y).GE.ONE)GO TO 330
C     EXTRAPOLATE IF 2 SUCCESSIVE LAMBDA'S AGREE WITHIN DCRIT.
      IF(IDEWIT.EQ.2)GO TO 240
      IF(DABS(Y-Y2).GT.DCRIT)GO TO 240
      LABEL = ' DEWAR'
  310 X=Y/(ONE-Y)
      DO 320 J=1,MOLX
      DO 320 I=1,NBASIS
  320 A3(I,J)=A3(I,J)+X*A2(I,J)
      ICOUNT=1
      IDEWIT=0
      IEXT=-1
      CALL SCHMDT(A3,A2,NBASIS)
      GO TO 920
C     SPECIAL VALUE OF LAMBDA FOR DIVERGENT CASES.
  330 Y=SP12/SP11
      LABEL = ' DEWAR'''
      GO TO 310
C     NO EXTRAPOLATION.
  900 ICOUNT=1
  910 CALL TWRITE(LOC,A3,NB,NR,NBASIS,MOLX,0)
  920 IF (LABEL .NE. ' ') CALL TWRITE(25,A3,NB,NB,NBASIS,NBASIS,0)
      IF(ITYPE.EQ.1)GO TO 930
C     SCF EXIT.
      ICSCF=ICOUNT
      IDWSCF=IDEWIT
      RETURN
C     CI EXIT.
  930 ICCI=ICOUNT
      IDWCI=IDEWIT
      RETURN
C*
C     ENTRIES TO PRESET CONVERGENCE ROUTINES.
C*
      ENTRY SETRHF
      ICSCF=0
      LOCSCF=32
      IDWSCF=0
      RETURN
      ENTRY SETCI
      ICCI=0
      LOCCI=40
      IDWCI=0
      DCRIT=PT06*DFLOAT(IOP(20)+1)
      IF(IOP(20).GE.7)DCRIT=TWO
      RETURN
      END
      SUBROUTINE CSD(MOLX,LABEL,MATCH)
C*
C     ON ENTRY, COLD CONTAINS THE OLD MO AND VV CONTAINS THE NEW MO.
C     ON EXIT, VV CONTAINS THE NEW MO, MATCHED BY SIGN TO THE OLD MO.
C     ON EXIT, MATCH IS SET FALSE IF A MATCHING FAILURE OCCURRED,
C     ELSE MATCH IS SET TRUE.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NR=#NR)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NR=101)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NB1=NB*(NB+1),
     1 NBP1=NB+1)
      PARAMETER (ZERO=0.0D0, ONE=1.0D0)
C
      COMMON /A/ IOP(99),IC1(6),IC2(NA),NBASIS,CD1(NA,3),CD2(4),IC3(401)
C
      COMMON/SCF1/ACURCY,COLD(NB,NBP1)
      COMMON/SCF2/SYMO(NB,NR),SCMO(NR,NR)
      COMMON/SCF3/VV(NB,NBP1)
C
      DIMENSION SS(NBB),MOTB(NR,NR),FILL2(NB1)
C
      LOGICAL MATCH
C
      CHARACTER*8 LABEL
C
      EQUIVALENCE (SYMO(1,1),SS(1),FILL2(1)), (COLD(1,1),MOTB(1,1))
C
      DATA PT5,PT7/0.5D0,0.7D0/
C
      MATCH = .TRUE.
      XMAX=PT7
      YMAX=-XMAX
      IJ=NBASIS*(NBASIS+1)/2
C     READ OVERLAP INTEGRALS
      CALL TREAD(8,SS,NBB,1,IJ,1,0)
C     GET A UNITARY MATRIX T SUCH THAT VV = COLD * T. THEREFORE
C     T = COLD' * S * VV.
      DO 20 IX=1,MOLX
      DO 20 K=1,MOLX
      SUM=ZERO
      IJ=0
      DO 10 I=1,NBASIS
      XMOT=ONE
      DO 10 J=1,I
      IJ=IJ+1
      IF(I.EQ.J)XMOT=PT5
   10 SUM=SUM+XMOT*(COLD(I,IX)*VV(J,K)+COLD(J,IX)*VV(I,K))*SS(IJ)
   20 SCMO(IX,K)=SUM
C     SCAN THE TWO-DIMENSIONAL TABLE SO AS TO PICK UP THE VALUES
C     LARGER THAN ABS(XMAX).
      DO 30 K=1,MOLX
      DO 30 IX=1,MOLX
      MOTB(IX,K)=0
      XX=SCMO(IX,K)
      IF(XX.GT.XMAX) MOTB(IX,K)=1
   30 IF(XX.LT.YMAX) MOTB(IX,K)=-1
C     CHECK WHETHER ONE-TO-ONE CORRESPONDENCE EXISTS OR NOT.
C     NORMALY ICOUNT SHOULD BE 1, OTHERWISE OUT OF THE REGULAR
C     CORRESPONDENCE
      DO 50 IX=1,MOLX
      ICOUNT=0
      JCOUNT=0
      DO 40 K=1,MOLX
      IF(MOTB(IX,K).NE.0) ICOUNT=ICOUNT+1
   40 IF(MOTB(K,IX).NE.0) JCOUNT=JCOUNT+1
      IF(ICOUNT.NE.1.OR.JCOUNT.NE.1) GO TO 90
   50 CONTINUE
      DO 70 K=1,MOLX
      DO 70 IX=1,MOLX
      IF(MOTB(IX,K).EQ.0) GO TO 70
      XMOT=DFLOAT(MOTB(IX,K))
      DO 60 J=1,NBASIS
   60 SYMO(J,IX)=VV(J,K)*XMOT
   70 CONTINUE
      DO 80 IX=1,MOLX
      DO 80 J=1,NBASIS
   80 VV(J,IX)=SYMO(J,IX)
      RETURN
   90 LABEL = 'NO MATCH'
      MATCH = .FALSE.
      RETURN
      END
      SUBROUTINE LAGRNG
C*
C     --------------
C     U OF T VERSION
C     MAY 1987
C     --------------
C*
C     CALCULATION OF LAGRANGE MULTIPLIERS AND ORBITAL ENERGIES.
C
C     ON EXIT, U CONTAINS THE CURRENT MO AND F CONTAINS THE FOCK
C     MATRICES.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NF=#NF, NC=#NC, NE=2*NB)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NF=120, NC=120, NE=2*NB)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NB1=NB*(NB+1),
     1 NBP1=NB+1)
      PARAMETER (NF2=NF+2)
      PARAMETER (ZERO=0.0D0, ONE=1.0D0)
C
      COMMON /A/ IOP(99),
     1 NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NED,NBASIS,C(NA,3),
     2 DUMC(4),IDUMC(401)
C
      COMMON/SCF1/ACURCY,U(NB,NB),DUM2(NB)
      COMMON/SCF2/F(NB1)
      COMMON/SCF3/SAVE(NB),T(NB,NB)
      COMMON/SCF4/EIG(NE),RN(NF),OCC(9),ALP(55),BETA(55),DUM4(NC),
     1 OCCA(9),OCCB(9),
     2 ICONF(NC),IRHF,NCONF,NCORE,NVAL,NOPEN,NFOCK,IMO(4),IA(NBP1),
     3 LLIM(NBB)
      COMMON/SCF5/XYZ(NBB,3)
      COMMON/IO/IODUM1(5),IMOINT,IFILE,JFILE,ILABEL,ICOUPL,IFORMT,
     1 IODUM2(206)
C
      DIMENSION S(NBB),IXBUFF(3072,2)
C
      EQUIVALENCE (XYZ(1,1),S(1),IXBUFF(1,1))
C
      DATA PT5/0.5D0/
C
      NN=NBASIS*(NBASIS+1)/2
      NOCC=NCORE+NVAL+NOPEN
      NCORE1=NCORE+1
      NMAX=NFOCK*NN
C
C     READ (PERTURBED) FOCK MATRIX.
C
      IF (IOP(3) .NE. 0) READ(JFILE)
      READ(JFILE)(F(I),I=1,NMAX)
      REWIND JFILE
      CALL TREAD(25,U,NB,NB,NBASIS,NBASIS,0)
      ICORE=1-NCORE
      IF(NCORE.EQ.0) GO TO 22
      NPASS=0
C     CORE-CORE.
    1 DO 12 I=1,NCORE
      DO 11 J=1,I
      IJ=IA(I)+J
      MM=0
      SUM=ZERO
      DO 10 M=1,NBASIS
      FMN=ONE
      DO 10 N=1,M
      MM=MM+1
      DA=U(M,I)*U(N,J)+U(N,I)*U(M,J)
      IF(N.EQ.M)FMN=PT5
      II=LLIM(MM)+1
   10 SUM=SUM+FMN*DA*F(II)
      T(I,J)=SUM
      T(J,I)=SUM
   11 S(IJ)=SUM
      EIG(I)=SUM
   12 EIG(NBASIS+I)=SUM
      IF(NPASS.NE.0.OR.NCORE.EQ.1)GO TO 13
C     DIAGONALIZE FROZEN CORE LAGRANGE MULTIPLIERS MATRIX E SUCH THAT
C     EDIAG = T' * E * T, WHERE T IS A UNITARY MATRIX.
      CALL TRED12(NCORE,NB,T,T,SAVE,DUM2,-2)
C     NOW THE EXACT CLOSED SHELL MO (X) ARE GIVEN BY X = U * T, WHERE
C     U IS THE CURRENT MO.
      DO 130 I=1,NBASIS
      DO 120 J=1,NCORE
      SUM=ZERO
      DO 110 K=1,NCORE
  110 SUM=SUM+U(I,K)*T(K,J)
  120 SAVE(J)=SUM
      DO 130 J=1,NCORE
  130 U(I,J)=SAVE(J)
      NPASS=1
      GO TO 1
C     CORE-VALENCE.
   13 IF(NCORE.EQ.NOCC)GO TO 40
      DO 21 I=NCORE1,NOCC
      IFIX=I+ICORE
      DO 21 J=1,NCORE
      IJ=IA(I)+J
      MM=0
      SUM=ZERO
      DO 20 M=1,NBASIS
      FMN=ONE
      DO 20 N=1,M
      MM=MM+1
      IF(N.EQ.M)FMN=PT5
      DA=U(M,I)*U(N,J)+U(N,I)*U(M,J)
      II=LLIM(MM)+IFIX
      JJ=LLIM(MM)+1
   20 SUM=SUM+FMN*DA*(F(II)+F(JJ))
   21 S(IJ)=PT5*SUM
C     VALENCE-VALENCE.
   22 DO 32 I=NCORE1,NOCC
      IFIX=I+ICORE
      DO 31 J=NCORE1,I
      JFIX=J+ICORE
      IJ=IA(I)+J
      MM=0
      SUM=ZERO
      DO 30 M=1,NBASIS
      FMN=ONE
      DO 30 N=1,M
      MM=MM+1
      IF(N.EQ.M)FMN=PT5
      DA=U(M,I)*U(N,J)+U(N,I)*U(M,J)
      II=LLIM(MM)+IFIX
      JJ=LLIM(MM)+JFIX
   30 SUM=SUM+FMN*DA*(F(II)+F(JJ))
   31 S(IJ)=PT5*SUM
      EIG(I)=S(IJ)
   32 EIG(NBASIS+I)=EIG(I)
C     LAGRANGE MULTIPLIERS FOR VIRTUAL ORBITALS.
   40 NOCC1=NOCC+1
      NVIRT=NBASIS-NOCC
      IF(NVIRT.LE.0)GO TO 900
      NPASS=0
C     VIRTUAL-VIRTUAL.
   50 II=0
      DO 80 I=NOCC1,NBASIS
      II=II+1
      JJ=0
      DO 70 J=NOCC1,I
      IJ=IA(I)+J
      MM=0
      SUM=ZERO
      DO 60 M=1,NBASIS
      FMN=ONE
      DO 60 N=1,M
      MM=MM+1
      DA=U(M,I)*U(N,J)+U(N,I)*U(M,J)
      IF(M.EQ.N)FMN=PT5
      KK=LLIM(MM)+1
   60 SUM=SUM+FMN*DA*F(KK)
      JJ=JJ+1
      T(II,JJ)=SUM
      T(JJ,II)=SUM
   70 S(IJ)=SUM
      EIG(I)=SUM
   80 EIG(NBASIS+I)=SUM
      IF(NPASS.NE.0.OR.NVIRT.EQ.1)GO TO 300
C     DIAGONALIZE VIRTUAL ORBITAL LAGRANGE MULTIPLIER MATRIX, AS ABOVE.
      CALL TRED12(NVIRT,NB,T,T,SAVE,DUM2,-2)
      DO 230 I=1,NBASIS
      DO 220 J=1,NVIRT
      SUM=ZERO
      DO 210 K=1,NVIRT
      KK=NOCC+K
  210 SUM=SUM+U(I,KK)*T(K,J)
      JJ=NOCC+J
  220 SAVE(JJ)=SUM
      DO 230 JJ=NOCC1,NBASIS
  230 U(I,JJ)=SAVE(JJ)
      NPASS=1
      GO TO 50
C     CORE-VIRTUAL.
  300 IF(NCORE.EQ.0)GO TO 400
      DO 320 I=NOCC1,NBASIS
      DO 320 J=1,NCORE
      IJ=IA(I)+J
      MM=0
      SUM=ZERO
      DO 310 M=1,NBASIS
      FMN=ONE
      DO 310 N=1,M
      MM=MM+1
      DA=U(M,I)*U(N,J)+U(N,I)*U(M,J)
      IF(M.EQ.N)FMN=PT5
      II=LLIM(MM)+1
  310 SUM=SUM+FMN*DA*F(II)
  320 S(IJ)=SUM
C     VALENCE-VIRTUAL.
  400 IF(NCORE.EQ.NOCC)GO TO 900
      DO 420 I=NOCC1,NBASIS
      DO 420 J=NCORE1,NOCC
      IJ=IA(I)+J
      JFIX=J+ICORE
      MM=0
      SUM=ZERO
      DO 410 M=1,NBASIS
      FMN=ONE
      DO 410 N=1,M
      MM=MM+1
      DA=U(M,I)*U(N,J)+U(N,I)*U(M,J)
      IF(M.EQ.N)FMN=PT5
      II=LLIM(MM)+1
      JJ=LLIM(MM)+JFIX
  410 SUM=SUM+FMN*DA*(F(II)+F(JJ))
  420 S(IJ)=PT5*SUM
C     PUT LAGRANGE MULTIPLIERS IN FILE 15.
  900 CALL TWRITE(15,S,NBB,1,NN,1,0)
      CALL TWRITE(25,U,NB,NB,NBASIS,NBASIS,0)
      RETURN
      END
      SUBROUTINE SCHMDT(F,S,NBASIS)
C*
C     --------------
C     U OF T VERSION
C     JANUARY 1987
C     --------------
C*
C     SCHMIDT ORTHOGONALIZE THE MO VECTORS IN F.  THIS IS
C     NECESSARY TO ENSURE THE CORRECT FORM OF THE PROJECTION OPERATORS.
C     S IS USED FOR SCRATCH.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C##
      PARAMETER (NA= 36, NB=200)
C###
      PARAMETER (ZERO=0.0D0, ONE=1.0D0)
C
      COMMON /A/ IOP(99)
      COMMON /A/ IC1(NA),IC2(7),C(NA,3),CD2(4),IC3(401)
C
      COMMON/IO/IN,IOUT,IODUM(215)
C
      DIMENSION F(NB,NB),S(NB,NB)
C
      DATA TENM10/1.0D-10/
C
 1000 FORMAT('0UNABLE TO SCHMIDT ORTHONORMALIZE THE MO - FAILURE ',
     1 'OCCURRED FOR MO',I4)
C*
C     GET THE OVERLAP MATRIX FROM FILE 8.
      CALL TREAD(8,S,NB,NB,NBASIS,NBASIS,1)
      DO 160 I=1,NBASIS
      DO 130 J=1,I
      OVLP=ZERO
C     CALCULATE OVERLAP BETWEEN MO I AND MO J.
      DO 110 K=1,NBASIS
      T=ZERO
      DO 100 L=1,NBASIS
  100 T=T+S(K,L)*F(L,I)
  110 OVLP=OVLP+T*F(K,J)
      IF(I.EQ.J)GO TO 140
C     PROJECT COMPONENT OF MO J OUT OF MO I.
      DO 120 K=1,NBASIS
  120 F(K,I)=F(K,I)-OVLP*F(K,J)
  130 CONTINUE
C     NORMALIZE MO I.
  140 IF(OVLP.LE.TENM10)GO TO 200
      OVLP=ONE/DSQRT(OVLP)
      DO 150 K=1,NBASIS
  150 F(K,I)=F(K,I)*OVLP
  160 CONTINUE
      RETURN
C     MO CANNOT BE ORTHONORMALIZED.
  200 WRITE(IOUT,1000) I
      IOP(1)=-2
      RETURN
      END
      SUBROUTINE CALDEN(D)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NF=#NF, NC=#NC, NE=2*NB)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NF=120, NC=120, NE=2*NB)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NBP1=NB+1)
      PARAMETER (ZERO=0.0D0)
C
      COMMON /A/ IOP(99),
     1 NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NED,NBASIS,CO(NA,3),
     2 DUMC(4),IDUMC(401)
C
      COMMON/SCF1/ACURCY,C(NB,NB),DUM1(NB)
      COMMON/SCF4/EIG(NE),RN(NF),OCC(9),ALP(55),BETA(55),DUM4(NC),
     1 OCCA(9),OCCB(9),
     2 ICONF(NC),IRHF,NCONF,NCORE,NVAL,NOPEN,NFOCK,IMO(4),ILIM(NBP1),
     3 LLIM(NBB)
C
      DIMENSION D(NBB)
C
      CALL TREAD(25,C,NB,NB,NBASIS,NBASIS,0)
      NTT=(NBASIS+1)*NBASIS/2
      DO 10 I=1,NTT
   10 D(I)=ZERO
      IF(NCORE.EQ.0) GO TO 30
      DO 20 I=1,NCORE
      II=0
      DO 20 K=1,NBASIS
      DO 20 L=1,K
      II=II+1
   20 D(II)=D(II)+RN(1)*C(K,I)*C(L,I)
   30 J=1
      IF(NVAL.EQ.0) GO TO 50
      ISTAT=IMO(1)
      ILAST=IMO(3)-1
      DO 40 I=ISTAT,ILAST
      II=0
      J=J+1
      DO 40 K=1,NBASIS
      DO 40 L=1,K
      II=II+1
   40 D(II)=D(II)+C(K,I)*C(L,I)*RN(J)
   50 IF(NOPEN.EQ.0) GO TO 70
      ISTAT=IMO(3)
      ILAST=IMO(4)-1
      DO 60 I=ISTAT,ILAST
      II=0
      J=J+1
      DO 60 K=1,NBASIS
      DO 60 L=1,K
      II=II+1
   60 D(II)=D(II)+C(K,I)*C(L,I)*RN(J)
   70 DO 80 I=1,NTT
   80 D(I)=D(I)+D(I)
      RETURN
      END
      SUBROUTINE CALENG(ENERGY)
C*
C     --------------
C     U OF T VERSION
C     MAY 1987
C     --------------
C*
C     ON ENTRY, C (EQUIVALENCED TO F) CONATINS THE MO VECTORS.
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NF=#NF, NC=#NC, NE=2*NB)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NF=120, NC=120, NE=2*NB)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NB1=NB*(NB+1),
     1 NBP1=NB+1)
      PARAMETER (ZERO=0.0D0, ONE=1.0D0, TWO=2.0D0)
C
      COMMON /A/ IOP(99),
     1 NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NED,NBASIS,CO(NA,3),
     2 DUMC(4),IDUMC(401)
C
      COMMON/SCF1/ACURCY,DB(NB1)
      COMMON/SCF2/F(NB1)
      COMMON/SCF4/EIG(NE),RN(NF),OCC(9),ALP(55),BETA(55),DUM4(NC),
     1 OCCA(9),OCCB(9),
     2 ICONF(NC),IRHF,NCONF,NCORE,NVAL,NOPEN,NFOCK,IMO(4),ILIM(NBP1),
     3 LLIM(NBB)
      COMMON/SCF5/XYZ(NBB,3)
      COMMON/GEN/E(6),DCONV,SPIN(2),FX,FY,FZ,FE,EMOL,ESOL,DP(4),VCM
      COMMON/IO/IODUM1(5),IMOINT,IFILE,JFILE,ILABEL,ICOUPL,IFORMT,
     1 IODUM2(206)
C
      DIMENSION C(NB,NB), H(NBB), IXBUFF(3072,2)
C
      EQUIVALENCE (F(1),C(1,1)), (XYZ(1,1),H(1),IXBUFF(1,1))
C
      NN=(NBASIS+1)*NBASIS/2
      NMAX=NN*NFOCK
      NFM1=NFOCK-1
      II=0
C
      DO 40 I=1,NBASIS
      DO 40 J=1,I
      II=II+1
      DB(II)=ZERO
      IF(NCORE.EQ.0)GO TO 20
      DO 10 K=1,NCORE
   10 DB(II)=DB(II)+C(I,K)*C(J,K)
   20 IF(NFM1.EQ.0)GO TO 40
      DO 30 K=1,NFM1
      KK=K+NCORE
      II=II+1
   30 DB(II)=C(I,KK)*C(J,KK)
   40 CONTINUE
C
C     READ CORE HAMILTONIAN INTO ARRAY H.
C
      CALL TREAD(13,H,NBB,1,NN,1,0)
C
C     READ IN UNPERTURBED FOCK MATRIX.
C
      READ(JFILE) (F(I),I=1,NMAX)
      REWIND JFILE
      ENERGY=ZERO
      II=0
      JJ=0
C
      DO 100 I=1,NBASIS
      FIJ=TWO
      DO 100 J=1,I
      II=II+1
      HVAL=H(II)
      IF(I.EQ.J)FIJ=ONE
      DO 100 K=1,NFOCK
      JJ=JJ+1
  100 ENERGY=ENERGY+FIJ*DB(JJ)*(F(JJ)+HVAL*RN(K))
C
C     ADD EXTERNAL ELECTRIC FIELD CONTRIBUTION IF NECESSARY.
C
      IF (IOP(3) .NE. 1) RETURN
C
C     READ DIPOLE INTEGRALS INTO ARRAY XYZ.
C
      CALL TREAD(34,XYZ(1,1),NBB,1,NN,1,0)
      CALL TREAD(35,XYZ(1,2),NBB,1,NN,1,0)
      CALL TREAD(36,XYZ(1,3),NBB,1,NN,1,0)
      II=0
      JJ=0
C
      DO 110 I=1,NBASIS
      FIJ=TWO
      DO 110 J=1,I
      II=II+1
      FXYZ = FX*XYZ(II,1) + FY*XYZ(II,2) + FZ*XYZ(II,3)
      IF(I.EQ.J)FIJ=ONE
      DO 110 K=1,NFOCK
      JJ=JJ+1
  110 ENERGY=ENERGY+FIJ*DB(JJ)*RN(K)*(FXYZ+FXYZ)
C
      RETURN
      END
      FUNCTION TRARHF(A,B,NBASIS,MOLX)
C*
C     --------------
C     U OF T VERSION
C     JANUARY 1987
C     --------------
C*
C     TRACE OF A PRODUCT OF TWO MATRICES A*B', EACH (#NB,#NR).
C*
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NB=#NB)
C     PARAMETER (NR=#NR)
C##
      PARAMETER (NB=200)
      PARAMETER (NR=101)
C###
      PARAMETER (ZERO=0.0D0)
C
      DIMENSION A(NB,NR),B(NB,NR)
C
      TRARHF=ZERO
      DO 10 J=1,MOLX
      DO 10 I=1,NBASIS
   10 TRARHF=TRARHF+A(I,J)*B(I,J)
      RETURN
      END
      SUBROUTINE RSCRFT (F, D)
C*
C     --------------
C     U OF T VERSION
C     MAY 1990
C     --------------
C*
C     THIS SUBROUTINE EVALUATES THE EFFECT OF EXTERNAL ELECTRIC FIELDS
C     AND SOLVENTS. THE EXTERNAL ELECTRIC FIELD WORKS FOR GSCF,
C     WHILE THE SOLVENT FIELD IS ONLY FOR CLOSED SHELL SCF.
C*
C     INPUT PARAMETERS:
C     F     - ARRAY CONTAINING CURRENT FOCK MATRICES; THE UPDATED FOCK
C             MATRICES ARE RETURNED.
C     D     - ARRAY CONTAINING CURRENT DENSITY MATRICES; THIS MATRIX WILL
C             NOT BE MODIFIED AND IS NOT USED FOR EXTERNAL ELECTRIC
C             FIELD CALCULATIONS.
C*
C     REFERENCES:
C     J.L. RIVAIL AND D. RINALDI, CHEM. PHYS., 18, 233 (1976);
C     R. CIMIRAGLIA, S. MIERTUS AND J. TOMASI, CHEM. PHYS. LETT., 80,
C     286 (1981).
C*
C     NOTE: AS SOME DOUBT STILL REMAINS AS TO THE INTERPRETATION
C     OF THE EQUATIONS OF SELF-CONSISTENT REACTION FIELD THEORY, THE
C     FOLLOWING DEFINES THE VALUES USED TO IMPLEMENT SCRFT IN
C     MONSTERGAUSS:
C     1) EMOL IS THE MOLECULAR ELECTRONIC ENERGY IN THE MEDIUM,
C     GIVEN BY EMOL=<I!H(I)!I>, WITH I THE COMPLETE PERTURBED WAVE
C     FUNCTION, AND H(I) THE PERTURBED HAMILTONIAN.
C     2) ESOL IS THE POLARIZATION ENERGY OF THE SOLVENT, GIVEN BY
C     ESOL=(1/2)*FE*DTOTAL*DTOTAL, WITH DTOTAL THE TOTAL DIPOLE MOMENT.
C     3) THE TOTAL ENERGY NOW BECOMES, ACCORDING TO THE EULER-
C     LAGRANGE METHOD, E3=EMOL+ESOL. ON CALLING SCRFT, E3 IS TAKEN
C     TO CONTAIN E1+E2, WHERE E1 IS THE NUCLEAR ENERGY, AND
C     E2=E(H0)=<I!H0(I)!I>, WHERE H0 IS THE UNPERTURBED HAMILTONIAN.
C     IN THIS CASE, THE TOTAL ENERGY MAY ALSO BE WRITTEN AS
C     E(H0)-ESOL.
C     4) THE DIPOLE MOMENT IS COMPUTED CORRECTLY FOR GSCF CASES, BUT
C     THE FOCK MATRIX CONTRIBUTIONS ARE STILL NOT CORRECT.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C#
C     PARAMETER (NA=#NA, NB=#NB)
C     PARAMETER (NF=#NF, NC=#NC, NE=2*NB)
C##
      PARAMETER (NA= 36, NB=200)
      PARAMETER (NF=120, NC=120, NE=2*NB)
C###
      PARAMETER (NBB=NB*(NB+1)/2, NB1=NB*(NB+1),
     1 NBP1=NB+1)
      PARAMETER (ZERO=0.0D0)
C
      COMMON /A/ IOP(99)
      COMMON /A/ NATOMS,ICHARG,MULTIP,IAN(NA),NAE,NBE,NED,NBASIS,C(NA,3)
      COMMON /A/ ANTOAU,DCONST,CDUM(2),ICDUM(401)
C
      COMMON/SCF4/EIG(NE),RN(NF),OCC(9),ALP(55),BETA(55),DUM4(NC),
     1 OCCA(9),OCCB(9),
     2 ICONF(NC),IRHF,NCONF,NCORE,NVAL,NOPEN,NFOCK,IMO(4),ILIM(NBP1),
     3 LLIM(NBB)
      COMMON/SCF5/XYZ(NBB,3)
C
      COMMON/GEN/E(6),DCONV,SPIN(2),FX,FY,FZ,FE,EMOL,ESOL,DP(4),VCM
      COMMON/IO/IN,IOUT,IODUM(215)
C
      DIMENSION F(NB1), D(NB1), IXBUFF(3072,2)
C
      EQUIVALENCE (XYZ(1,1),IXBUFF(1,1))
C
      DATA PT5/0.5D0/
C
 1020 FORMAT(22X,'X:',1PD14.6,10X,'Y:',D14.6,10X,'Z:',D14.6,10X,'TOTAL:'
     1 ,D14.6/22X,'EMOL =',0PF17.9,'   ESOL =',F17.9)
C
      NN = NBASIS * (NBASIS+1) / 2
C
C     READ DIPOLE INTEGRALS.
C
      CALL TREAD (34, XYZ(1,1), NBB, 1, NN, 1, 0)
      CALL TREAD (35, XYZ(1,2), NBB, 1, NN, 1, 0)
      CALL TREAD (36, XYZ(1,3), NBB, 1, NN, 1, 0)
C
C     WHAT TYPE OF CASE IS IT?
C     IOP(3)=1 ... THE CALCULATION IS DONE IN THE PRESENCE OF AN
C                  EXTERNAL UNIFORM ELECTRIC FIELD.
C     IOP(3)=2 ... THE CALCULATION IS DONE TO INCLUDE SOLVENT EFFECTS.
C
      IF (IOP(3) .EQ. 2) GO TO 200
C
C     CALCULATE THE EFFECT OF AN EXTERNAL ELECTRIC FIELD.
C
      JJ = 0
      DO 100 J=1,NBASIS
      DO 100 I=1,J
      JJ = JJ + 1
      IJ = LLIM(JJ)
      T = FX*XYZ(JJ,1) + FY*XYZ(JJ,2) + FZ*XYZ(JJ,3)
      DO 100 K=1,NFOCK
      II = IJ + K
      F(II) = F(II) + RN(K)*T
  100 CONTINUE
C
      RETURN
C
C     EVALUATION OF ELECTRIC DIPOLE MOMENT FOR SOLVENT EFFECTS.
C
  200 CONTINUE
C
C     FORM TRACE OF PRODUCT  D*XYZ, BY COMPONENTS.
C
      TEX = ZERO
      TEY = ZERO
      TEZ = ZERO
      JJ = 0
      DO 210 J=1,NBASIS
      DO 210 I=1,J
      JJ = JJ + 1
      IJ = LLIM(JJ)
      DO 210 K=1,NFOCK
      II = IJ + K
      TEX = TEX - D(II)*XYZ(JJ,1)
      TEY = TEY - D(II)*XYZ(JJ,2)
      TEZ = TEZ - D(II)*XYZ(JJ,3)
  210 CONTINUE
C
C     ADD IN NUCLEAR CONTRIBUTION.
C
      TNX = ZERO
      TNY = ZERO
      TNZ = ZERO
      DO 220 I=1,NATOMS
      IF (IAN(I) .LE. 0) GO TO 220
      AN = IAN(I)
      TNX = TNX + C(I,1)*AN
      TNY = TNY + C(I,2)*AN
      TNZ = TNZ + C(I,3)*AN
  220 CONTINUE
C
C     ADD NUCLEAR CONTRIBUTION TO DIPOLE MOMENT.
C
      DP(1) = TEX + TNX
      DP(2) = TEY + TNY
      DP(3) = TEZ + TNZ
C
C     DETERMINE THE CONTRIBUTION TO THE FOCK MATRIX.
C     FORM THE DOT PRODUCT BETWEEN THE FIELD AND DIPOLE MOMENT.
C
      TX = (TEX+TNX) * FE
      TY = (TEY+TNY) * FE
      TZ = (TEZ+TNZ) * FE
      JJ = 0
      DO 230 J=1,NBASIS
      DO 230 I=1,J
      JJ = JJ + 1
      IJ = LLIM(JJ)
      T = TX*XYZ(JJ,1) + TY*XYZ(JJ,2) + TZ*XYZ(JJ,3)
      DO 230 K=1,NFOCK
      II = IJ + K
  230 F(II) = F(II) + RN(K)*T
C
C     GET TOTAL DIPOLE MOMENT.
C
      DP(4) = DSQRT(DP(1)*DP(1)+DP(2)*DP(2)+DP(3)*DP(3))
C
C     CALCULATE EMOL, ESOL, AND TOTAL ENERGY.
C     CONVERT DIPOLE MOMENT TO DEBYES.
C
      ESOL = PT5 * FE * DP(4) * DP(4)
      E(2) = E(2) - ESOL
      EMOL = E(2) - ESOL
      DP(1) = DP(1) * DCONST
      DP(2) = DP(2) * DCONST
      DP(3) = DP(3) * DCONST
      DP(4) = DP(4) * DCONST
      IF (IOP(31) .NE. 0) WRITE (IOUT,1020) DP, EMOL, ESOL
      RETURN
      END
