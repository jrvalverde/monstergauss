C
C     PROGRAM CONVRT2
C
C     PURPOSE
C        MODIFY A SERIES OF SOURCE FILES FOR IBM/CDC/VAX/UNX USE.
C
C     AUTHOR: MIKE PETERSON, U OF TORONTO CHEMISTRY DEPARTMENT.
C     VERSION: 04 OCT 92.
C
C     INPUT PARAMETERS:
C
C     PNAMES  - PARAMETER NAMES AND VALUES TO BE USED BY CONVRT2.
C               THESE PARAMETERS WILL BE REFERED TO AS 'PRIMARY
C               PARAMETERS' BECAUSE THE OTHER PARAMETERS ARE DEFINED
C               IN TERMS OF THEM.
C
C               EACH LINE IS IN THE FORM:
C
C               #ABCDEFG=12345678
C
C               WITH THE '#' CHARACTER IN COLUMN 1, WHERE 'ABCDEFG' IS
C               THE NAME OF THE PARAMETER (LEFT JUSTIFIED AND BLANK
C               FILLED), AND '12345678' IS THE PARAMETER VALUE
C               (I8 FORMAT). THE REMAINDER OF THE INPUT LINE MAY
C               BE USED FOR COMMENTS.
C
C               THE FIRST LINE SHOULD BE ONE OF:
C               #MACH   =GLD      CONVERT TO GOULD SYSTEM (FORT77N)
C               #MACH   =GBR      CONVERT TO GOULD SYSTEM (FORTX32)
C               #MACH   =IBM      CONVERT TO IBM SYSTEM
C               #MACH   =CDC      CONVERT TO CDC SYSTEM
C               #MACH   =VAX      CONVERT TO VAX SYSTEM
C               #MACH   =UNX      CONVERT TO UNIX-BASED SYSTEM
C               TERMINATE THE LIST OF PARAMETER NAMES WITH A BLANK CARD.
C
C     FNAMES  - PATH NAMES TO BE COPIED/CONVERTED. IF COLUMNS 67-72
C               CONTAIN 'NOSCAN', THE FILE WILL NOT BE SCANNED FOR
C               MACHINE-SPECIFIC FEATURES.
C
C     FOR EXAMPLE, TO CREATE AN IBM VERSION FOR UP TO 150 ATOMIC
C     ORBITALS, THE FOLLOWING WOULD BE SUITABLE:
C
C     #MACH   =IBM      CONVERT TO IBM SYSTEM
C     #NA     =      30 NUMBER OF ATOMS
C     #NB     =     150 NUMBER OF BASIS FUNCTIONS (A.O.'S)
C     #NS     =      80 NUMBER OF SHELLS
C     #NP     =     250 NUMBER OF PRIMITIVE GAUSSIANS
C     #NR     =      76 NUMBER OF OCCUPIED ORBITALS IN RHF
C     #NF     =     100 NUMBER OF FOCK MATRICES IN RHF
C     #NC     =     100 NUMBER OF CONFIGURATIONS IN RHF
C     #NO     =     125 NUMBER OF OPTIMIZABLE PARAMETERS
C     #NT     =      60 NUMBER OF TRANSFORMED ORBITALS
C     #NCON   =   32000 NUMBER OF CONFIGURATIONS IN CI
C     #MA     =      15 NUMBER OF ACTIVE OCCUPIED MO IN CI
C     #MV     =      40 NUMBER OF ACTIVE SUBSTITUTING MO IN CI
C     #NDHF   =     100 NUMBER OF BASIS FUNCTIONS IN DHF
C     #IRECL  =    6232 RECORD SIZE IN BYTES (GOULD=6144, IBM=6232,
C                       REST=6400)
C
C     GL0100A
C     GL0100B
C      ...
C     GL9999
C
C     THE VARIABLE 'MASTER', INITIALIZED IN A DATA STATEMENT
C     BELOW, CONTROLS THE TYPE OF INPUT FILE EXPECTED: SETTING
C     'MASTER'='UNX' TELLS CONVRT2 THAT THE INPUT SOURCE CODE
C     IS SET UP FOR UNIX SYSTEMS.
C
C     THE FOLLOWING TYPES OF CONVERSIONS ARE PERFORMED BY THIS PROGRAM
C     (OPTIONAL PARTS OF LINES ARE INDICATED BY '[' AND ']'):
C
C     1. MACHINE DEPENDENT CODE WHICH REQUIRES NO REDIMENSIONING.
C
C        THESE CODE SECTIONS ARE IDENTIFIED BY 'C?XXX[/XXX...]'
C        STARTING IN COLUMN 1 OF AN INPUT LINE, WHERE 'XXX' IS ONE OF
C        'GLD', 'GBR', 'IBM', 'CDC', 'VAX' OR 'UNX'. ADDITIONAL OPTIONAL
C        'XXX' CODES ARE EXTRA NAMES FOR WHICH THE FOLLOWING CODE IS
C        ALSO TO BE USED. THE END OF THE BLOCK OF CODE IS INDICATED BY
C        'C??' STARTING IN COLUMN 1. COMMENT LINES WITHIN A C?/C??
C        BLOCK ARE INDICATED BY 'C*' IN COLUMNS 1 AND 2. THE ENTIRE
C        BLOCK MUST BE COMMENTED OFF UNLESS IT IS SUPPOSED TO BE
C        ACTIVE FOR THE 'MASTER' MACHINE.
C
C     2. CODE WHICH REQUIRES REDIMENSIONING - THE CODE MAY OPTIONALLY
C        BE MACHINE SPECIFIC ALSO.
C
C        THESE CODE SECTIONS ARE IDENTIFIED BY 'C#[XXX/XXX...]'
C        STARTING IN COLUMN 1 OF AN INPUT LINE, WHERE 'XXX' IS ONE OF
C        'GLD', 'GBR', 'IBM', 'CDC', 'VAX' OR 'UNX'. THE OPTIONAL 'XXX'
C        CODES ARE THE MACHINE NAMES FOR WHICH THE FOLLOWING CODE IS
C        TO BE USED. THE END OF THE BLOCK OF CODE IS INDICATED BY
C        'C###' STARTING IN COLUMN 1. COMMENT LINES WITHIN A C#/C###
C        BLOCK ARE INDICATED BY 'C*' IN COLUMNS 1 AND 2. THE ENTIRE
C        BLOCK MUST BE COMMENTED OFF UNLESS IT IS SUPPOSED TO BE
C        ACTIVE FOR THE 'MASTER' MACHINE.
C        THE C#/C### BLOCK IS BROKEN INTO 2 EQUAL PARTS BY A LINE
C        CONTAINING 'C##' IN COLUMNS 1 AND 2 - THE FIRST SECTION
C        IS CALLED THE PROTOTYPE SECTION, AND EACH LINE ALWAYS HAS
C        A 'C' IN COLUMN 1. ARRAY DIMENSIONS AND/OR VALUES SPECIFIED
C        IN DATA STATEMENTS MAY BE REPLACED BY PARAMETER NAMES, WHICH
C        ALWAYS BEGIN WITH THE '#' CHARACTER. THE SECOND 'ACTIVE'
C        SECTION IS AN EXACT COPY OF THE FIRST SECTION, EXCEPT THAT
C        THE PARAMETERS HAVE BEEN REPLACED BY THE APPROPRIATE VALUES
C        AND THE 'C' IN COLUMN 1 HAS BEEN TAKEN OFF THE NON-
C        COMMENT LINES, PROVIDED THE BLOCK IS ACTIVE ON THE 'MASTER'
C        MACHINE. AS AN EXAMPLE, CONSIDER THE FOLLOWING:
C
C                  C#GLD/GBR/IBM/VAX/UNX                   (1)
C                  C     COMMON /TEST/ A(#NB,#NB), B(10)   (2)
C                  C*    THIS IS A COMMENT LINE.           (3)
C                  C     DATA MAXA/#NB/, MAXB/10/          (4)
C                  C##                                     (5)
C                        COMMON /TEST/ A( 90, 90), B(10)   (6)
C                  C*    THIS IS A COMMENT LINE.           (7)
C                        DATA MAXA/ 90/, MAXB/10/          (8)
C                  C###                                    (9)
C
C        LINE (1) INDICATES THAT REDIMENSIONING IS REQUIRED FOR THE
C        FOLLOWING BLOCK OF CODE, WHICH IS ONLY ACTIVE ON THE GOULD
C        (BOTH FORT77N AND FORTX32 COMPILERS), IBM, VAX AND UNX
C        MACHINES.
C        LINE (2) IS A VARIABLY-DIMENSIONED ARRAY, WITH THE DIMENSION
C        SPECIFIED BY THE VALUE OF THE PARAMETER '#NB' (90 IN THIS
C        EXAMPLE). NOTE THAT FIXED DIMENSIONS ARE ALLOWED ON THE
C        SAME LINE.
C        LINE (3) IS A COMMENT LINE.
C        LINE (4) SHOWS THE USE OF A PARAMETER IN A DATA STATEMENT.
C        NOTE THAT DATA VALUES CONTAINING CONSTANTS ARE PERMITTED ON
C        THE SAME LINE.
C        LINE (5) INDICATES THE END OF THE PROTOTYPE SECTION.
C        LINE (6) IS THE COMMON STATEMENT AS ACTUALLY USED BY
C        MONSTERGAUSS.
C        LINE (7) IS THE COMMENT LINE, IDENTICAL TO LINE (3).
C        LINE (8) IS THE DATA STATEMENT AS ACTUALLY USED BY
C        MONSTERGAUSS.
C        LINE (9) INDICATES THE END OF THE REDIMENSIONING BLOCK.
C
C     3. FOR CONVERSIONS TO CDC, 'DOUBLE PRECISION' IS CHANGED TO
C        'REAL            ' AS NO DOUBLE PRECISION ARITHMETIC IS USED
C        ON THE CDC MACHINE.
C        IN ADDITION, THE FOLLOWING DOUBLE PRECISION LIBRARY ROUTINES
C        ARE CONVERTED TO THEIR SINGLE PRECISION COUNTERPARTS:
C        DFLOAT, DSQRT, DABS, DEXP, IDINT, DATAN, DSIN, DCOS, DSIGN,
C        DLOG, DMAX1 AND DMIN1.
C        ONCE THESE CHANGES HAVE BEEN MADE, THE PROGRAM CAN NOT BE
C        RECONVERTED TO A GOULD/IBM/VAX/UNX VERSION.
C
C     *** THIS PROGRAM IS INTENDED FOR UNIX SYSTEMS ONLY ***
C
      PROGRAM CONVRT2
C
      PARAMETER (MAXNAM=50)
C?UNIX
      character homedir*100
C??
C?GOULD
C     INTEGER*8 TASK/'GAUCONV2'/
C
C     INTEGER ICODE/'CRAP'/
C??
      CHARACTER LINE80*80, FILENAME*66
      CHARACTER*8 NAMES, ZFILE
      CHARACTER*6 SCAN, NOSCAN
      CHARACTER*3 GLD, IBM, CDC, VAX, GBR, UNX, BLANK3, CODE3,
     1 MACH, MASTER
      CHARACTER*1 LINE(80), C, Q, HASH, BLANK, STAR, SLASH,
     1 PROTO(80,25)
C
      LOGICAL*1 GOTQ, GOTHASH, OLDACTIV, NEWACTIV, LAST,
     1 PROTOSEC, CALLCDC
C
      COMMON /CON2/ NAMES(MAXNAM), LENGTH(MAXNAM), IVAL(MAXNAM),
     1 IUSED(MAXNAM), NNAMES
C
      EQUIVALENCE (LINE80,LINE(1))
C
      DATA MASTER/'UNX'/, MAXPROTO/25/
      DATA NOSCAN/'NOSCAN'/
      DATA GLD/'GLD'/, IBM/'IBM'/, CDC/'CDC'/, VAX/'VAX'/,
     1 GBR/'GBR'/, UNX/'UNX'/, BLANK3/'   '/
      DATA C/'C'/, Q/'?'/, HASH/'#'/, BLANK/' '/,
     1 STAR/'*'/, SLASH/'/'/
      DATA CALLCDC/.FALSE./
C
C
C?UNIX
C     GET HOME DIRECTORY NAME.
C
      call getenv ('HOME', homedir)
      nhome = index (homedir, ' ')
      if (nhome .le. 0) go to 9190
      homedir(nhome:nhome) = '/'
C??
C?GOULD
C     OPEN 1 LARGE FILE FOR THE CONVERTED OUTPUT.
C     THIS FILE IS NORMALLY USED IN THE FOLLOWING WAY WHEN RUNNING
C     CONVRT2 ON THE GOULD:
C
C        $NOTE COPY MONSTERGAUSS SOFTWARE SOURCE TO TAPE.
C        $IFF PATH J.TAPEOUT NODELETE
C        $NOTE DELETE (GAU)J.TAPEOUT.
C        $DELETE J.TAPEOUT
C        $DEFNAME NODELETE
C        $NOTE CREATE FILE D.NEWVERSION (IF NECESSARY).
C        $IFT PATH D.NEWVERSION SKIP
C        $EXEC VOLMGR CRE D.NEWVERSION SIZE=15000 NOSAVE=T SEGN=5
C        $DEFNAME SKIP
C        $NOTE CONVERT GOULD SOURCE TO EXTERNAL SOURCE CODE.
C        $AS 2 TO D.NEWVERSION BBUF=10
C        $RUN GAUCONV2
C
C     OPEN (UNIT=2, BLOCKED=.TRUE.)
C     REWIND 2
C??
      NTOTAL = 0
      NCTOTAL = 0
C
C     INPUT PARAMETER DATA.
C
      CALL PARAMS (MACH, *9900)
      IF (MASTER.EQ.CDC .AND. MACH.NE.CDC) GO TO 9120
      IF (MASTER.NE.CDC .AND. MACH.EQ.CDC) CALLCDC = .TRUE.
      IF (CALLCDC) CALL CDCSET
C
      NFILE = 0
      WRITE (6,910) MASTER, MACH
  910 FORMAT ('1CONTENTS OF OUTPUT TAPE FROM CONVRT2',5X,'(CONVERT ',
     1 A3,' INPUT TO ',A3,' OUTPUT)'/
     2 '0FILE',5X,'SOURCE FILE',24X,'# DEACT.',5X,
     3 '# ACTIV.',5X,'# COPIED'/)
C*
C     GET NEXT FILE NAME.
C*
 1000 READ (5,1010,END=8000) FILENAME, SCAN
 1010 FORMAT (A66,A6)
C
      NFILE = NFILE + 1
      GOTQ = .FALSE.
      GOTHASH = .FALSE.
      NDEACT = 0
      NACT = 0
      NCOP = 0
C?UNIX
C     OPEN SEPARATE OUTPUT FILES IN /tmp/newgauss FOR EACH INPUT FILE.
C
      open (unit=1, file=homedir(1:nhome)//filename, err=9020,
     1 iostat=istat, status='old')
      write (zfile,1020) nfile
 1020 format ('file',i3.3)
      open (unit=2, file='/tmp/newgauss/'//zfile, err=9180,
     1 iostat=istat)
C??
C?GOULD
C     OPEN (UNIT=1, BLOCKED=.TRUE., ERR=9020, FILE=FILENAME,
C    1 FORM='FORMATTED', IOSTAT=ISTAT, OPENMODE='R', STATUS='OLD',
C    2 WAIT=.TRUE.)
C     CALL M:READST
C??
C*
C     READ INPUT FILE, LINE BY LINE.
C*
C?UNIX
 2000 read (1,2010,end=7000,err=9030) line80
 2010 format (a)
C??
C?GOULD
C2000 CALL M:READ (1, LINE80, 80, *7000, *9030)
C??
      IF (SCAN .EQ. NOSCAN) GO TO 6100
      IF (GOTQ) GO TO 3000
      IF (GOTHASH) GO TO 4000
C*
C     NORMAL LINES - CHECK FOR THE START OF A C? OR C# SECTION.
C*
      IF (LINE(1) .NE. C) GO TO 6000
      IF (LINE(2) .EQ. HASH) GO TO 2100
      IF (LINE(2) .NE. Q) GO TO 6000
C
C     GOT 'C?'.
C
      GOTQ = .TRUE.
C
C     GET MACHINE CODES: C?XXX/XXX/XXX ... OR C#XXX/XXX/XXX ... .
C     A BLANK MACHINE CODE IS ONLY ACCEPTABLE FOR C# BLOCKS, AND THEN
C     ONLY IF NO OTHER MACHINE CODE IS PRESENT.
C
 2020 N = 2
      OLDACTIV = .FALSE.
      NEWACTIV = .FALSE.
      LAST = .FALSE.
C
 2050 IF (N .GT. 68) GO TO 9060
      CODE3 = LINE80(N+1:N+3)
      N = N + 4
      IF (LINE(N) .EQ. SLASH) GO TO 2060
      IF (LINE(N) .NE. BLANK) GO TO 9060
      LAST = .TRUE.
C
 2060 IF (CODE3.NE.GLD .AND. CODE3.NE.GBR .AND. CODE3.NE.IBM .AND.
     1 CODE3.NE.CDC .AND. CODE3.NE.VAX .AND. CODE3.NE.UNX .AND.
     2 CODE3.NE.BLANK3) GO TO 9060
      IF (GOTQ .AND. CODE3.EQ.BLANK3) GO TO 9060
      IF (.NOT.LAST .AND. CODE3.EQ.BLANK3) GO TO 9060
      IF (CODE3.EQ.BLANK3 .AND. N.NE.6) GO TO 9060
      IF (CODE3.EQ.MASTER .OR. CODE3.EQ.BLANK3) OLDACTIV = .TRUE.
      IF (CODE3.EQ.MACH .OR. CODE3.EQ.BLANK3) NEWACTIV = .TRUE.
      IF (LAST) GO TO 6000
      GO TO 2050
C
C     GOT 'C#'.
C
 2100 GOTHASH = .TRUE.
      PROTOSEC = .TRUE.
      NPROTO = 0
      GO TO 2020
C*
C     C? SECTION.
C
C     C* INDICATES AN IMBEDDED COMMENT.
C     C?? INDICATES THE END OF THE SECTION.
C     OTHER LINES ARE ACTIVATED OR DEACTIVATED AS NECESSARY.
C*
 3000 IF (LINE(1) .NE. C) GO TO 3100
      IF (LINE(2) .EQ. STAR) GO TO 6000
      IF (LINE(2).NE.Q .OR. LINE(3).NE.Q .OR. LINE(4).NE.BLANK)
     1 GO TO 3200
C
C     GOT 'C??' - END OF SECTION.
C
      GOTQ = .FALSE.
      GO TO 6000
C
C     FIRST CHARACTER WAS NOT A 'C' - THIS LINE BETTER BE ACTIVE.
C
 3100 IF (.NOT. OLDACTIV) GO TO 9040
      IF (NEWACTIV) GO TO 6000
C
C     DEACTIVATE THIS LINE.
C
      NDEACT = NDEACT + 1
      LINE(1) = C
      GO TO 6000
C
C     FIRST CHARACTER WAS A 'C' - THIS LINE BETTER BE INACTIVE.
C     ALSO CHECK FOR '?' OR '#' IN COLUMN 2 - BOTH ARE INVALID.
C
 3200 IF (OLDACTIV) GO TO 9050
      IF (LINE(2).EQ.Q .OR. LINE(2).EQ.HASH) GO TO 9050
      IF (.NOT. NEWACTIV) GO TO 6000
C
C     ACTIVATE THIS LINE.
C
      NACT = NACT + 1
      LINE(1) = BLANK
      GO TO 6000
C*
C     C# SECTION.
C
C     C* INDICATES AN IMBEDDED COMMENT.
C     C## INDICATES THE END OF THE PROTOTYPE SECTION.
C     C### INDICATES THE END OF THE REPLACEMENT SECTION.
C     LINES IN THE PROTOTYPE SECTION ARE ACCUMULATED, AND
C     LINES IN THE REPLACEMENT SECTION ARE MODIFIED ACCORDING
C     TO THE PARAMETER VALUES, THEN ACTIVATED OR DEACTIVATED
C     AS NECESSARY.
C*
 4000 IF (.NOT. PROTOSEC) GO TO 4100
C
C     PROTOTYPE SECTION - ACCUMULATE LINES IN 'PROTO'.
C     LOOK FOR 'C##' TO END THIS SECTION.
C
      IF (LINE(1) .NE. C) GO TO 9130
      IF (LINE(2).EQ.HASH .AND. LINE(3).EQ.HASH .AND. LINE(4).EQ.BLANK)
     1 GO TO 4050
      NPROTO = NPROTO + 1
      IF (NPROTO .GT. MAXPROTO) GO TO 9140
      DO 4010 I=1,80
 4010 PROTO(I,NPROTO) = LINE(I)
      GO TO 6000
C
C     GOT 'C##' - END OF PROTOTYPE SECTION. DO CONVERSION.
C
 4050 IF (NPROTO .EQ. 0) GO TO 9150
      PROTOSEC = .FALSE.
      CALL CONVERT (FILENAME, PROTO, MAXPROTO, NPROTO, *9900)
      NREPLACE = 0
      GO TO 6000
C
C     REPLACEMENT SECTION - CHECK FOR 'C###'.
C
 4100 IF (LINE(1).EQ.C .AND. LINE(2).EQ.HASH .AND. LINE(3).EQ.HASH
     1 .AND. LINE(4).EQ.HASH .AND. LINE(5).EQ.BLANK) GO TO 4900
      IF (LINE(1) .EQ. C) GO TO 4200
C
C     FIRST CHARACTER WAS NOT A 'C' - THIS LINE BETTER BE ACTIVE.
C
      IF (.NOT. OLDACTIV) GO TO 9070
      IF (NEWACTIV) GO TO 4300
C
C     DEACTIVATE THIS LINE.
C
      NDEACT = NDEACT + 1
      LINE(1) = C
      GO TO 4300
C
C     FIRST CHARACTER WAS A 'C' - THIS LINE BETTER BE INACTIVE.
C     ALSO CHECK FOR '?' OR '#' IN COLUMN 2 - BOTH ARE INVALID.
C
 4200 IF (LINE(2) .EQ. STAR) GO TO 4300
      IF (OLDACTIV) GO TO 9080
      IF (LINE(2).EQ.Q .OR. LINE(2).EQ.HASH) GO TO 9080
      IF (.NOT. NEWACTIV) GO TO 4300
C
C     ACTIVATE THIS LINE.
C
      NACT = NACT + 1
      LINE(1) = BLANK
C
C     COPY REPLACEMENT LINE FROM CONVERTED PROTOTYPE.
C
 4300 NREPLACE = NREPLACE + 1
      IF (NREPLACE .GT. NPROTO) GO TO 9160
      DO 4310 I=2,72
C     IF (LINE(1).EQ.' ' .AND. LINE(I).NE.PROTO(I,NREPLACE)) THEN
C        WRITE (6,9990) FILENAME, LINE80, (PROTO(J,NREPLACE),J=1,80)
C9990    FORMAT ('0REPLACEMENT LINE DOES NOT MATCH PROTOTYPE IN FILE ',
C    1    A30/' ORIGINAL   : ',A80/' REPLACEMENT: ',80A1)
C        GO TO 9900
C     END IF
 4310 LINE(I) = PROTO(I,NREPLACE)
      GO TO 6000
C
C     GOT 'C###' - END OF REPLACEMENT SECTION.
C
 4900 IF (NPROTO .NE. NREPLACE) GO TO 9170
      GOTHASH = .FALSE.
C*
C     COPY LINE TO OUTPUT FILE.
C*
 6000 IF (CALLCDC .AND. LINE(1).NE.C) CALL CDCCONV (LINE)
 6100 WRITE (2,6110) LINE80
 6110 FORMAT (A80)
      NCOP = NCOP + 1
      NTOTAL = NTOTAL + 1
      IF (LINE(1).EQ.C .AND. SCAN.NE.NOSCAN) NCTOTAL = NCTOTAL + 1
      GO TO 2000
C*
C     END-OF-FILE ON FILE 1.
C*
 7000 IF (GOTQ) GO TO 9000
      IF (GOTHASH) GO TO 9010
      CLOSE (UNIT=1)
      ENDFILE 2
C?UNIX
      close (unit=2)
C??
      WRITE (6,7010) NFILE, FILENAME, NDEACT, NACT, NCOP
 7010 FORMAT (1X,I3,6X,A30,5X,I6,7X,I6,8X,I6)
      GO TO 1000
C*
C     END PROCESSING - PREPARE TAPE COPY JOB.
C*
C?UNIX
 8000 continue
C??
C?GOULD
C8000 ENDFILE 2
C     REWIND 2
C     CLOSE (UNIT=2)
C??
      WRITE (6,8010) NTOTAL, NCTOTAL
 8010 FORMAT (/'0',I10,' SOURCE LINES COPIED,  INCLUDING',I8,
     1 ' COMMENT LINES.')
C
C     DUMP VARIABLE USE COUNTS.
C
      WRITE (6,8050)
 8050 FORMAT ('1VARIABLE    VALUE    # TIMES USED'/)
      DO 8060 I=1,NNAMES
 8060 WRITE (6,8070) NAMES(I), IVAL(I), IUSED(I)
 8070 FORMAT (1X,A8,I9,4X,I8)
      IF (CALLCDC) CALL CDCDUMP
C
C     CREATE JCL FILE TAPE.JOB AND WRITE IT OUT.
C
C?UNIX
      open (unit=3, file='/tmp/tape.job', err=9100, iostat=istat,
     1 status='new')
      write (3,8100) mach
 8100 format ('#! /bin/csh'/
     1 '#'/
     2 '# Tape.job - copy Monstergauss files from /tmp/newgauss'/
     3 '#            to magnetic tape.'/
     4 '#'/
     5 '# Usage: /tmp/tape.job >&/tmp/tape.out &'/
     6 '#'/
     7 'echo "Prepare tape of Monstergauss for ',a,' system."')
      write (3,8110) nfile
 8110 format ('echo " "'/
     1 'echo "Copy ',i3,' files to tape."'/
     2 'echo " "'/
     3 'echo "Tape is: NO LABEL,"'/
     4 'echo "         80 BYTE RECORDS,"'/
     5 'echo "         6400 BYTE BLOCKS,"'/
     6 'echo "         6250 BPI."'/
     7 'echo " "')
      write (3,8120)
 8120 format ('rwmt -w -dev m0 -f 1 -unlab -rl 80 -bl 6400 ',
     1 '/tmp/newgauss/file0[0-9][0-9]'/
     2 'rwmt -w -dev m0 -f cur -unlab -rl 80 -bl 6400 ',
     3 '/tmp/newgauss/file1[0-9][0-9]'/
     4 'echo " "'/
     5 '/usr/apollo/bin/mt -f /dev/rmts8 -scsi rewind')
C??
C?GOULD
C     OPEN (UNIT=3, BLOCKED=.TRUE., CLEAR=.TRUE., ERR=9100,
C    1 FILE='J.TAPEOUT', FILESIZE=8, IOSTAT=ISTAT, STATUS='NEW')
C     WRITE (3,8100) MACH
C8100 FORMAT ('$JOB J.TAPEOUT GAU,1080 SLOD=NU'/
C    1 '$NOTE PREPARE EXTERNAL TAPE FOR MONSTERGAUSS SOURCE.'/
C    2 '$EXEC TAPEOUT'/
C    3 'FILE,D.NEWVERSION'/
C    4 'AS,OUT,MT,',A3/
C    5 'REW,OUT')
C     WRITE (3,8110) NFILE
C8110 FORMAT ('BLKSIZE,6400'/
C    1 'COPY,',I3/
C    2 'REW,IN'/
C    3 'REW,OUT'/
C    4 'EXIT'/
C    5 '$NOTE'/
C    6 '$NOTE FILE D.NEWVERSION MAY BE DELETED.'/
C    7 '$NOTE'/
C    8 '$EOJ'/
C    9 '$$')
C??
      ENDFILE 3
      CLOSE (UNIT=3)
      WRITE (6,8200)
 8200 FORMAT (/'0File /tmp/tape.job ready for editting/submission.')
      STOP
C
C     ERROR SECTION.
C
 9000 WRITE (6,9001) FILENAME
 9001 FORMAT ('0END-OF-FILE INSIDE A C? SECTION FOR FILE ',A30)
      GO TO 9900
C
 9010 WRITE (6,9011) FILENAME
 9011 FORMAT ('0END-OF-FILE INSIDE A C# SECTION FOR FILE ',A30)
      GO TO 9900
C
 9020 WRITE (6,9021) FILENAME, ISTAT
 9021 FORMAT ('0UNABLE TO OPEN FILE ',A66/' ISTAT =',I12,'.')
      GO TO 9900
C
 9030 WRITE (6,9031) FILENAME
 9031 FORMAT ('0I/O ERROR ON FILE ',A66)
      GO TO 9900
C
 9040 WRITE (6,9041) FILENAME, LINE80, NCOP
 9041 FORMAT ('0NON-COMMENT LINE FOUND INSIDE AN INACTIVE C? SECTION ',
     1 'FOR FILE ',A30/' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9050 WRITE (6,9051) FILENAME, LINE80, NCOP
 9051 FORMAT ('0ILLEGAL COMMENT LINE INSIDE A C? SECTION ',
     1 'FOR FILE ',A30/' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9060 WRITE (6,9061) FILENAME, LINE80, NCOP
 9061 FORMAT ('0ILLEGAL C? OR C# LINE FOR FILE ',A30/' LINE: ',A80/
     1 ' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9070 WRITE (6,9071) FILENAME, LINE80, NCOP
 9071 FORMAT ('0NON-COMMENT LINE FOUND INSIDE AN INACTIVE C# SECTION ',
     1 'FOR FILE ',A30/' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9080 WRITE (6,9081) FILENAME, LINE80, NCOP
 9081 FORMAT ('0ILLEGAL COMMENT LINE INSIDE A C# SECTION ',
     1 'FOR FILE ',A30/' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9100 WRITE (6,9101) ISTAT
 9101 FORMAT ('0UNABLE TO CREATE/OPEN FILE TAPE.JOB, ISTAT =',I12)
      GO TO 9900
C
 9120 WRITE (6,9121) MASTER, MACH
 9121 FORMAT ('0',A3,' SOURCE CAN NOT BE CONVERTED TO ',A3,' SOURCE.')
      GO TO 9900
C
 9130 WRITE (6,9131) FILENAME, LINE80, NCOP
 9131 FORMAT ('0NON-COMMENT LINE FOUND INSIDE A C# PROTOTYPE SECTION ',
     1 'FOR FILE ',A30/' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9140 WRITE (6,9141) FILENAME, MAXPROTO, LINE80, NCOP
 9141 FORMAT ('0TOO MANY PROTOTYPE LINES (LIMIT = MAXPROTO =',I4,
     1 ') FOR FILE ',A30/' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9150 WRITE (6,9151) FILENAME, LINE80, NCOP
 9151 FORMAT ('0NO PROTOTYPE SECTION FOUND IN C# BLOCK FOR FILE ',A30/
     1 ' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9160 WRITE (6,9161) FILENAME, LINE80, NCOP
 9161 FORMAT ('0TOO MANY REPLACEMENT LINES IN C# BLOCK FOR FILE ',A30/
     1 ' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C
 9170 WRITE (6,9171) FILENAME, LINE80, NCOP
 9171 FORMAT ('0TOO FEW REPLACEMENT LINES IN C# BLOCK FOR FILE ',A30/
     1 ' LINE: ',A80/' ERROR OCCURED AFTER LINE',I5)
      GO TO 9900
C?UNIX
 9180 WRITE (6,9181) ZFILE, ISTAT
 9181 FORMAT ('0UNABLE TO CREATE/OPEN FILE /tmp/',A,', ISTAT =',I12)
      GO TO 9900
C
 9190 WRITE (6,9191) HOMEDIR
 9191 FORMAT ('0Home directory name is too long:'/1x,A)
C
 9900 call exit (1)
C??
C?GOULD
C9900 CALL M:ABORT (TASK, ICODE)
C??
      STOP
      END
      SUBROUTINE PARAMS (MACH, *)
C
C     THIS ROUTINE READS THE PARAMETER NAMES AND DEFINES THE
C     REMAINING SECONDARY PARAMETERS.
C
C     ARGUMENT DESCRIPTIONS:
C     MACH   - THE NAME OF THE MACHINE THE SOURCE IS TO BE CONVERTED
C              TO (ONE OF 'GLD', 'GBR', 'IBM', 'CDC', 'VAX' OR 'UNX').
C              THIS ARGUMENT RETURNED BY ROUTINE PARAMS.
C     *      - ERROR RETURN ADDRESS (SUPPLIED BY CALLING ROUTINE).
C
C     THE DIMENSIONS OF ARRAYS NAMES, LENGTH, IVAL AND IUSED IS
C     GIVEN BY VARIABLE 'MAXNAM', IN AN ASSIGNMENT STATEMENT IN THE
C     MAIN PROGRAM.
C
      PARAMETER (MAXNAM=50)
C
      INTEGER NFILE(100,2), ITEN(8)
C
      CHARACTER*72 INLINE
      CHARACTER*8 NAMES, BLANK8, FIRSTL, PRIMNAME(14)
      CHARACTER*3 GLD, IBM, CDC, VAX, GBR, UNX, MACH
      CHARACTER*1 HASH, EQUAL, BLANK1
C
      LOGICAL ERROR
C
      COMMON /CON2/ NAMES(MAXNAM), LENGTH(MAXNAM), IVAL(MAXNAM),
     1 IUSED(MAXNAM), NNAMES
C
      DATA NPRIM/14/
      DATA ITEN/1,10,100,1000,10000,100000,1000000,10000000/
      DATA BLANK8/'        '/, FIRSTL/'#MACH   '/,
     1 PRIMNAME/'#NA     ','#NB     ','#NS     ','#NP     ',
     2 '#NR     ','#NF     ','#NC     ','#NO     ','#NT     ',
     3 '#NCON   ','#MA     ','#MV     ','#NDHF   ','#IRECL  '/
      DATA GLD/'GLD'/, IBM/'IBM'/, CDC/'CDC'/, VAX/'VAX'/,
     1 GBR/'GBR'/, UNX/'UNX'/
      DATA HASH/'#'/, EQUAL/'='/, BLANK1/' '/
C
C
      NNAMES = NPRIM
      DO 10 I=1,MAXNAM
      NAMES(I) = BLANK8
      LENGTH(I) = 0
      IVAL(I) = 0
   10 IUSED(I) = 0
      WRITE (6,20)
   20 FORMAT ('1INPUT PARAMETERS:'/)
C
C     GET MACHINE TO CONVERT TO.
C
      READ (5,100,END=9000) INLINE
  100 FORMAT (A72)
      WRITE (6,110) INLINE
  110 FORMAT (1X,A72)
      IF (INLINE(1:8).NE.FIRSTL .OR. INLINE(9:9).NE.EQUAL) GO TO 9010
      MACH = INLINE(10:12)
      IF (MACH.NE.GLD .AND. MACH.NE.GBR .AND. MACH.NE.IBM .AND.
     1 MACH.NE.CDC .AND. MACH.NE.VAX .AND. MACH.NE.UNX) GO TO 9010
      IF (INLINE(13:17) .NE. ' ') GO TO 9010
      IREAL = 2
      IF (MACH .EQ. CDC) THEN
         IINT = 2
      ELSE
         IINT = 1
      END IF
C
C     READ PRIMARY PARAMETER NAMES AND VALUES, COPYING THEM TO THE
C     NAMES ARRAY AS THEY ARE FOUND.
C
  200 READ (5,100,END=300) INLINE
      IF (INLINE(1:1).EQ.BLANK1 .AND. INLINE(2:2).EQ.BLANK1) GO TO 300
      WRITE (6,110) INLINE
      IF (INLINE(1:1).NE.HASH .OR. INLINE(9:9).NE.EQUAL) GO TO 9010
      DO 210 I=1,NPRIM
      IF (INLINE(1:8) .EQ. PRIMNAME(I)) GO TO 220
  210 CONTINUE
      GO TO 9020
C
  220 IF (NAMES(I) .NE. BLANK8) GO TO 9030
      NAMES(I) = INLINE(1:8)
      READ (INLINE(10:17),230) IVAL(I)
  230 FORMAT (I8)
      IF (IVAL(I) .LE. 0) GO TO 9040
      GO TO 200
C
C     ENSURE ALL PRIMARY PARAMETERS DEFINED.
C
  300 ERROR = .FALSE.
      DO 320 I=1,NPRIM
      IF (NAMES(I) .NE. BLANK8) GO TO 320
      WRITE (6,310) PRIMNAME(I)
  310 FORMAT ('0*** PRIMARY PARAMETER ',A8,' NOT DEFINED.')
      ERROR = .TRUE.
  320 CONTINUE
      IF (ERROR) RETURN 1
C
C     GET VALUES OF PRIMARY PARAMETERS INDIVIDUALLY.
C
      NA = IVAL(1)
      NB = IVAL(2)
      NS = IVAL(3)
      NP = IVAL(4)
      NR = IVAL(5)
      NF = IVAL(6)
      NC = IVAL(7)
      NO = IVAL(8)
      NT = IVAL(9)
      NCON = IVAL(10)
      MA = IVAL(11)
      MV = IVAL(12)
      NDHF = IVAL(13)
      IRECL = IVAL(14)
C
C     ENSURE PRIMARY PARAMETERS OBEY THEIR RESTRICTIONS.
C
      ERROR = .FALSE.
C     NA MUST BE EVEN, >2, <100.
      IF ((NA/2)*2.EQ.NA .AND. NA.GT.2 .AND. NA.LT.100) GO TO 410
      WRITE (6,401)
  401 FORMAT ('0*** PARAMETER ERROR: NA MUST BE EVEN, >2, <100.')
      ERROR = .TRUE.
C     NB MUST BE EVEN, <500, >=NA+9 (L601).
  410 IF ((NB/2)*2.EQ.NB .AND. NB.LT.500 .AND. NB.GE.NA+9) GO TO 420
      WRITE (6,411)
  411 FORMAT ('0*** PARAMETER ERROR: NB MUST BE EVEN, <500, >=NA+9.')
      ERROR = .TRUE.
C     NS MUST BE EVEN, <1000, <=NP.
  420 IF ((NS/2)*2.EQ.NS .AND. NS.LT.1000 .AND. NS.LE.NP) GO TO 430
      WRITE (6,421)
  421 FORMAT ('0*** PARAMETER ERROR: NS MUST BE EVEN, <1000, <=NP.')
      ERROR = .TRUE.
C     NP MUST BE <1000.
  430 IF (NP .LT. 1000) GO TO 440
      WRITE (6,431)
  431 FORMAT ('0*** PARAMETER ERROR: NP MUST BE <1000.')
      ERROR = .TRUE.
C     NR MUST BE <NB.
  440 IF (NR .LT. NB) GO TO 450
      WRITE (6,441)
  441 FORMAT ('0*** PARAMETER ERROR: NR MUST BE <NB.')
      ERROR = .TRUE.
C     NF MUST BE <1000.
  450 IF (NF .LT. 1000) GO TO 460
      WRITE (6,451)
  451 FORMAT ('0*** PARAMETER ERROR: NF MUST BE <1000.')
      ERROR = .TRUE.
C     NC MUST BE EVEN, <1000.
  460 IF ((NC/2)*2.EQ.NC .AND. NC.LT.1000) GO TO 470
      WRITE (6,461)
  461 FORMAT ('0*** PARAMETER ERROR: NC MUST BE EVEN, <1000.')
      ERROR = .TRUE.
C     NO MUST BE <1000.
  470 IF (NO .LT. 1000) GO TO 480
      WRITE (6,471)
  471 FORMAT ('0*** PARAMETER ERROR: NO MUST BE <1000.')
      ERROR = .TRUE.
C     NT MUST BE EVEN, <=NB.
  480 IF ((NT/2)*2.EQ.NT .AND. NT.LE.NB) GO TO 490
      WRITE (6,481)
  481 FORMAT ('0*** PARAMETER ERROR: NT MUST BE EVEN, <=NB.')
      ERROR = .TRUE.
C     NCON MUST BE <=32000.
  490 IF (NCON .LE. 32000) GO TO 500
      WRITE (6,491)
  491 FORMAT ('0*** PARAMETER ERROR: NCON MUST BE <=32000.')
      ERROR = .TRUE.
C     MA MUST BE <=NT.
  500 IF (MA .LE. NT) GO TO 510
      WRITE (6,501)
  501 FORMAT ('0*** PARAMETER ERROR: MA MUST BE <=NT.')
      ERROR = .TRUE.
C     MV MUST BE <NT.
  510 IF (MV .LT. NT) GO TO 520
      WRITE (6,511)
  511 FORMAT ('0*** PARAMETER ERROR: MV MUST BE <NT.')
      ERROR = .TRUE.
C     NDHF MUST BE <=NB.
  520 IF (NDHF .LE. NB) GO TO 530
      WRITE (6,521)
  521 FORMAT ('0*** PARAMETER ERROR: NDHF MUST BE <=NB.')
      ERROR = .TRUE.
C     IRECL MUST BE DIVISIBLE BY 8.
  530 IF ((IRECL/8)*8 .EQ. IRECL) GO TO 540
      WRITE (6,531)
  531 FORMAT ('0*** PARAMETER ERROR: IRECL MUST BE DIVISIBLE BY 8.')
      ERROR = .TRUE.
C     IRECL MUST BE DIVISIBLE BY 768 FOR GLD/GBR VERSIONS.
  540 IF (MACH.NE.GLD .AND. MACH.NE.GBR) GO TO 550
      IF ((IRECL/768)*768 .EQ. IRECL) GO TO 550
      WRITE (6,541)
  541 FORMAT ('0*** PARAMETER ERROR: IRECL MUST BE DIVISIBLE BY 768.')
      ERROR = .TRUE.
C
  550 IF (ERROR) RETURN 1
C
C     EVALUATE ALL SECONDARY PARAMETERS - SOME ARE NEEDED TO
C     CALCULATE THE PARTITION LENGTHS ON UNIT 'IMAT', OR TO HANDLE
C     DATA RESTRICTIONS.
C
      NA3 = 3*NA
      NA3SQ = NA3*NA3
      NZ = NA3-6
      NV = NA3/2
C     NV2 = 2*NV
C     NV4 = 4*NV
      NFOR = 8+6*NA3+6*NP
      NBB = NB*(NB+1)/2
C     NBB1 = NBB+1
      NB1 = NB*(NB+1)
      NB2 = NB*NB
C     NBF1 = NB*NB-NBB
C     NBP1 = NB+1
C     NBP3 = NB+3
C     NE = 2*NB
C     NR1 = NR+1
      NF2 = NF+2
      NOO = NO*(NO+1)/2
C     NT1 = NT*(NT+1)/2
C     NT3 = NT*NT*(NT+1)/2
      MA1 = MA*(MA+1)/2
      MV1 = MV*(MV+1)/2
C     NDHF1 = NDHF*(NDHF+1)/2
C     NDHFP1 = NDHF+1
C     IRECL8 = IRECL/8
C     LRECDHF = (NDHF*NDHF+IRECL8-1)/IRECL8
C     IBLKFAC = (IRECL+767)/768
C
C     ACCOUNT FOR REMAINING RESTRICTIONS.
C
C     (NB+NR)*NR <= NB1 (L503, ROUTINE CSD).
      IF ((NB+NR)*NR .LE. NB1) GO TO 710
      WRITE (6,701)
  701 FORMAT ('0*** PARAMETER ERROR: (NB+NR)*NR MUST BE <= NB1.')
      ERROR = .TRUE.
C     NB*NR >= NBB (L503, ROUTINE CSD).
  710 IF (NB*NR .GE. NBB) GO TO 720
      WRITE (6,711)
  711 FORMAT ('0*** PARAMETER ERROR: NB*NR MUST BE >= NBB.')
      ERROR = .TRUE.
C     NR*NR <= NB*(NB-NR) (L701/L702).
  720 IF (NR*NR .LE. NB*(NB-NR)) GO TO 730
      WRITE (6,721)
  721 FORMAT ('0*** PARAMETER ERROR: NR*NR MUST BE <= NB*(NB-NR).')
      ERROR = .TRUE.
C     NA3 <= NO (L202/L711A).
  730 IF (NA3 .LE. NO) GO TO 740
      WRITE (6,731)
  731 FORMAT ('0*** PARAMETER ERROR: NA3 MUST BE <= NO.')
      ERROR = .TRUE.
C     11*NO <= NFOR (L202/L711A).
  740 IF (11*NO .LE. NFOR) GO TO 750
      WRITE (6,741)
  741 FORMAT ('0*** PARAMETER ERROR: 11*NO MUST BE <= NFOR.')
      ERROR = .TRUE.
C     NO(REAL)+36(INTEGER)+21(REAL)+NOO(REAL) <= NA3SQ (L711B, ROUTINES
C     OC/DOC).
  750 IF (NO+36+21+NOO .LE. NA3SQ) GO TO 760
      WRITE (6,751)
  751 FORMAT ('0*** PARAMETER ERROR: NO+36+21+NOO MUST BE <= NA3SQ.')
      ERROR = .TRUE.
C     NO(REAL)+10(INTEGER)+17(REAL)+NOO(REAL) <= NA3SQ (L711C, ROUTINE
C     BFGS).
  760 IF (NO+10+17+NOO .LE. NA3SQ) GO TO 770
      WRITE (6,761)
  761 FORMAT ('0*** PARAMETER ERROR: NO+10+17+NOO MUST BE <= NA3SQ.')
      ERROR = .TRUE.
C     10*NV(REAL)+34(REAL)+20(INTEGER) <= NFOR (L711C, ROUTINE VA05MP).
  770 IF (10*NV+34+20 .LE. NFOR) GO TO 780
      WRITE (6,771)
  771 FORMAT ('0*** PARAMETER ERROR: 10*NV+34+20 MUST BE <= NFOR.')
      ERROR = .TRUE.
C     6400(INTEGER) <= NB1 (L501/502).
  780 I = 6400 * IINT / 2
      IF (I .LE. NB1) GO TO 900
      WRITE (6,781) I
  781 FORMAT ('0*** PARAMETER ERROR: NB1 MUST BE >=',I5,'.')
      ERROR = .TRUE.
C
  900 IF (ERROR) RETURN 1
      LFC = 6
C
C     GET PARTITION LENGTHS ON UNIT IMAT, AND TOTAL NUMBER OF BLOCKS.
C     DO IT FOR THE GOULD MACHINE FIRST.
C
      IF (MACH.EQ.GLD .OR. MACH.EQ.GBR) THEN
         IRECSZ = ((IRECL/4)+191) / 192
         WRITE (6,910)
  910    FORMAT ('1DIRECT ACCESS FILE DATA TABLE (ARRAY NFILE IN ',
     1    'COMMON /IO/) FOR GOULD MACHINE (GLD/GBR):')
         CALL CRITIC (NA,NB,NS,NP,NF,NC,NO,NT,MA,
     1    NZ,NA3,NBB,NB1,NB2,NF2,NFOR,NV,MA1,MV1,
     2    NFILE,IREAL,IINT,IRECL,IRECSZ,NTBLKS,ERROR,LFC,LFC)
         CALL DEFINE ('#NBLOCK ', NTBLKS, *9900)
      END IF
C
C     REPEAT FOR IBM/VAX/UNX.
C
      IRECSZ = 1
      IF (MACH.EQ.IBM .OR. MACH.EQ.VAX .OR. MACH.EQ.UNX) THEN
         WRITE (6,920)
  920    FORMAT ('1DIRECT ACCESS FILE DATA TABLE (ARRAY NFILE IN ',
     1    'COMMON /IO/) FOR IBM/VAX/UNX MACHINES:')
         CALL CRITIC (NA,NB,NS,NP,NF,NC,NO,NT,MA,
     1    NZ,NA3,NBB,NB1,NB2,NF2,NFOR,NV,MA1,MV1,
     2    NFILE,IREAL,IINT,IRECL,IRECSZ,NTBLKS,ERROR,LFC,LFC)
         CALL DEFINE ('#NBLOCK ', NTBLKS, *9900)
      END IF
C
C     REPEAT FOR CDC MACHINE.
C
      IF (MACH .EQ. CDC) THEN
         WRITE (6,930)
  930    FORMAT ('1DIRECT ACCESS FILE DATA TABLE (ARRAY NFILE IN ',
     1    'COMMON /IO/) FOR CDC MACHINES:')
         CALL CRITIC (NA,NB,NS,NP,NF,NC,NO,NT,MA,
     1    NZ,NA3,NBB,NB1,NB2,NF2,NFOR,NV,MA1,MV1,
     2    NFILE,IREAL,IINT,IRECL,IRECSZ,NTBLKS,ERROR,LFC,LFC)
         I = IRECL / 8
         J = I * NTBLKS
         WRITE (6,940) IRECL, I, J
  940    FORMAT (' NOTE: AN IBM/VAX/UNX BLOCK SIZE OF',I6,' BYTES IS',
     1    I6,' WORDS ON CDC, FOR A TOTAL FILE LENGTH OF',I10,' WORDS.')
         CALL DEFINE ('#NBLOCK ', NTBLKS, *9900)
      END IF
C
C     GET MINIMUM NUMBER OF SPACES REQUIRED FOR EACH NAME AND VALUE.
C
      DO 950 I=1,NNAMES
      LENGTH(I) = 2
      INLINE(1:8) = NAMES(I)
      IVALI = IVAL(I)
      DO 950 J=3,8
      IF (INLINE(J:J).EQ.BLANK1 .AND. IVALI.LT.ITEN(J)) GO TO 950
      LENGTH(I) = J
  950 CONTINUE
C
C     WRITE (6,9991)
C9991 FORMAT ('1DUMP OF INITIAL PARAMETER ARRAYS:'/
C    1 '0  I   NAMES      LENGTH       IVAL   IUSED'/)
C     DO 9992 I=1,NNAMES
C9992 WRITE (6,9993) I, NAMES(I), LENGTH(I), IVAL(I), IUSED(I)
C9993 FORMAT (1X,I3,3X,A8,3X,I6,3X,I8,3X,I5)
C
      RETURN
C
C     ERROR SECTION.
C
 9000 WRITE (6,9001)
 9001 FORMAT ('0*** NO INPUT PARAMETERS FOUND.')
      RETURN 1
C
 9010 WRITE (6,9011)
 9011 FORMAT ('0*** ABOVE PARAMETER INPUT LINE IS INVALID.')
      RETURN 1
C
 9020 WRITE (6,9021)
 9021 FORMAT ('0*** PARAMETER NAME ON ABOVE INPUT LINE NOT FOUND ',
     1 'IN LIST OF PRIMARY NAMES.')
      RETURN 1
C
 9030 WRITE (6,9031)
 9031 FORMAT ('0*** ABOVE PRIMARY PARAMETER NAME DEFINED TWICE.')
      RETURN 1
C
 9040 WRITE (6,9041)
 9041 FORMAT ('0*** PARAMETER VALUE ON ABOVE INPUT LINE IS INVALID.')
      RETURN 1
C
 9900 RETURN 1
      END
      SUBROUTINE DEFINE (PNAME, IPVAL, *)
C
C     THIS SUBROUTINE ADDS THE SECONDARY PARAMETER NAMES
C     AND VALUES TO THE LIST OF PARAMETERS.
C
C     ARGUMENT DESCRIPTIONS:
C     PNAME  - A CHARACTER*8 VARIABLE CONTAINING THE PARAMETER NAME.
C     IPVAL  - THE VALUE OF THE PARAMETER.
C     *      - ERROR RETURN ADDRESS.
C
      PARAMETER (MAXNAM=50)
C
      CHARACTER*8 NAMES, PNAME
C
      COMMON /CON2/ NAMES(MAXNAM), LENGTH(MAXNAM), IVAL(MAXNAM),
     1 IUSED(MAXNAM), NNAMES
C
C
      NNAMES = NNAMES + 1
      IF (NNAMES .GT. MAXNAM) GO TO 9000
      WRITE (6,110) PNAME, IPVAL
  110 FORMAT (1X,A8,'=',I8)
      NAMES(NNAMES) = PNAME
      IVAL(NNAMES) = IPVAL
      RETURN
C
C     ERROR EXIT.
C
 9000 WRITE (6,9001) MAXNAM
 9001 FORMAT ('0*** MAXIMUM NUMBER OF PARAMETERS EXCEEDED (LIMIT =',
     1 I4,').')
      RETURN 1
      END
      SUBROUTINE CONVERT (FILENAME, PROTO, MAXPROTO, NPROTO, *)
C
C     THIS ROUTINE CONVERTS PROTOTYPE CODE TO ACTUAL CODE BY REPLACING
C     THE '#' VARIABLES WITH THE PROPER VALUES.
C
C     SUBROUTINE ARGUMENTS:
C     FILENAME - CURRENT FILE NAME.
C     PROTO    - CHARACTER*1 ARRAY CONTAINING THE PROTOTYPE SECTION.
C     MAXPROTO - MAXIMUM NUMBER OF PROTOTYPE LINES ALLOWED.
C     NPROTO   - NUMBER OF PROTOTYPE LINES IN CURRENT SECTION.
C     *        - ERROR RETURN ADDRESS.
C
      PARAMETER (MAXNAM=50)
C
      CHARACTER*66 FILENAME
      CHARACTER*8 NAMES, NAME, ZBUFF
      CHARACTER*4 IFORMAT(8)
      CHARACTER*1 PROTO(80,MAXPROTO), HASH, STAR, COMMA,
     1 RIGHTP, SLASH, I1
C
      COMMON /CON2/ NAMES(MAXNAM), LENGTH(MAXNAM), IVAL(MAXNAM),
     1 IUSED(MAXNAM), NNAMES
C
      DATA IFORMAT/'(I1)','(I2)','(I3)','(I4)','(I5)','(I6)',
     1 '(I7)','(I8)'/
      DATA HASH/'#'/, STAR/'*'/, COMMA/','/, RIGHTP/')'/, SLASH/'/'/
C
C
C     SCAN EACH PROTOTYPE LINE.
C
      DO 200 N=1,NPROTO
C     WRITE (6,9990) (PROTO(I,N),I=1,80)
C9990 FORMAT (' PROTOTYPE: ',80A1)
      IF (PROTO(2,N) .EQ. STAR) GO TO 200
C
C     SCAN FOR A '#' CHARACTER.
C
      ICOL = 1
C
  100 ICOL = ICOL + 1
      IF (ICOL .GT. 70) GO TO 200
      IF (PROTO(ICOL,N) .NE. HASH) GO TO 100
C
C     LOOK FOR A DELIMITER CHARACTER: COMMA, RIGHT PARENTHESIS OR SLASH.
C
      ISTART = ICOL
C
  120 ICOL = ICOL + 1
      IF (ICOL .GT. 72) GO TO 9000
      I1 = PROTO(ICOL,N)
      IF (I1.NE.COMMA .AND. I1.NE.RIGHTP .AND. I1.NE.SLASH) GO TO 120
C
C     GOT DELIMITER - LOOK UP NAME IN LIST OF VARIABLES.
C
      IEND = ICOL - 1
      L = ICOL - ISTART
      IF (L.LE.1 .OR. L.GT.8) GO TO 9010
      WRITE (NAME,130) (PROTO(I,N),I=ISTART,IEND)
  130 FORMAT (8A1)
C
      DO 140 I=1,NNAMES
      IF (NAME .EQ. NAMES(I)) GO TO 150
  140 CONTINUE
      GO TO 9020
C
  150 IF (L .LT. LENGTH(I)) GO TO 9030
      WRITE (ZBUFF, IFORMAT(L)) IVAL(I)
      DO 160 J=1,L
  160 PROTO(ISTART+J-1,N) = ZBUFF(J:J)
      IUSED(I) = IUSED(I) + 1
C     WRITE (6,9991) NAME, (PROTO(I,N),I=1,80)
C9991 FORMAT (1X,A8,' : ',80A1)
      GO TO 100
C
  200 CONTINUE
C
      RETURN
C
C     ERROR EXITS.
C
 9000 WRITE (6,9001)
 9001 FORMAT ('0NO DELIMITER CHARACTER FOUND BEFORE COLUMN 72, IN ',
     1 'PROTOTYPE CONVERSION.')
      GO TO 9900
C
 9010 WRITE (6,9011) L, ICOL
 9011 FORMAT ('0ILLEGAL VARIABLE NAME LENGTH',I3,', STARTING IN ',
     1 'COLUMN',I3,', IN PROTOTYPE SECTION.')
      GO TO 9900
C
 9020 WRITE (6,9021) NAME
 9021 FORMAT ('0VARIABLE NAME ',A8,' NOT FOUND IN LIST OF VARIABLES.')
      GO TO 9900
C
 9030 WRITE (6,9031) NAME, LENGTH(I), L
 9031 FORMAT ('0VARIABLE ',A8,' NEEDS',I2,' COLUMNS, BUT ONLY',I2,
     1 ' COLUMNS AVAILABLE.')
C
 9900 WRITE (6,9901) (PROTO(I,N),I=1,80), FILENAME
 9901 FORMAT (' ERROR OCCURRED FOR LINE: ',80A1/' IN FILE ',A66)
      RETURN 1
      END
      SUBROUTINE CDCCONV (LINE)
C
C     THIS ROUTINE CONVERTS ARRAY 'LINE' FOR USE ON CDC MACHINES.
C     THE FOLLOWING CONVERSIONS ARE DONE:
C     'DOUBLE PRECISION' --> 'REAL            '
C     'DFLOAT          ' --> ' FLOAT          '
C     'DSQRT           ' --> ' SQRT           '
C     'DABS            ' --> ' ABS            '
C     'DEXP            ' --> ' EXP            '
C     'IDINT           ' --> '  INT           '
C     'DATAN           ' --> ' ATAN           '
C     'DSIN            ' --> ' SIN            '
C     'DCOS            ' --> ' COS            '
C     'DSIGN           ' --> ' SIGN           '
C     'DLOG            ' --> 'ALOG            '
C     'DMAX1           ' --> 'AMAX1           '
C     'DMIN1           ' --> 'AMIN1           '
C     FOR THE STRING TO BE FOUND, THE NEXT NON-BLANK CHARACTER ON THE
C     SAME LINE MUST BE A '(', EXCEPT FOR 'DOUBLE PRECISION'
C     WHICH WILL ALSO BE ACCEPTED IF IT STARTS IN COLUMN 7
C     BUT IS NOT FOLLOWED BY A '('.
C
C     ARGUMENT DESCRIPTION:
C     LINE     - SOURCE LINE TO BE CONVERTED.
C
C     PARAMETER DESCRIPTIONS:
C     IREP16   - STRINGS TO BE SEARCHED FOR.
C     JREP16   - REPLACEMENT STRINGS.
C     NREP     - NUMBER OF REPLACEMENTS TO BE CHECKED.
C
C     ARRAY DIMENSIONS:
C     NREP: IREP1, IREP16, JREP1, JREP16, LENGTH, IFIRST, NUSED.
C
      INTEGER LENGTH(13), NUSED(13)
C
      CHARACTER*1 LINE(80), IREP1(16,13), JREP1(16,13),
     1 BLANK, IFIRST(13), I1, LEFTP
      CHARACTER*16 IREP16(13), JREP16(13)
C
      SAVE
C
      EQUIVALENCE (IREP1(1,1),IREP16(1)), (JREP1(1,1),JREP16(1))
C
      DATA NREP/13/
      DATA BLANK/' '/, LEFTP/'('/
C
C     LIST OF CONVERSIONS (NOTE: 'DOUBLE PRECISION' MUST
C     BE FIRST IN THE LIST).
C
      DATA IREP16/'DOUBLE PRECISION',
     1 'DFLOAT  ','DSQRT   ','DABS    ',
     2 'DEXP    ','IDINT   ','DATAN   ','DSIN    ','DCOS    ',
     3 'DSIGN   ','DLOG    ','DMAX1   ','DMIN1   '/
      DATA JREP16/'REAL            ',
     1 ' FLOAT  ',' SQRT   ',' ABS    ',
     2 ' EXP    ','  INT   ',' ATAN   ',' SIN    ',' COS    ',
     3 ' SIGN   ','ALOG    ','AMAX1   ','AMIN1   '/
C
C
C     SEARCH FOR KEY FIRST CHARACTERS.
C
      ICOL = 6
C     IPRINT = 0
C
  100 ICOL = ICOL + 1
      IF (ICOL .GT. LASTCOL) RETURN
      I1 = LINE(ICOL)
      DO 110 I=1,NFIRST
      IF (I1 .EQ. IFIRST(I)) GO TO 200
  110 CONTINUE
      GO TO 100
C
C     GOT A MATCHING FIRST CHARACTER - TRY FOR A FULL STRING.
C
  200 IOFFSET = ICOL - 1
C
      DO 250 I=1,NREP
      L = LENGTH(I)
      IF (IOFFSET+L .GT. 72) GO TO 250
      DO 210 J=1,L
      IF (LINE(IOFFSET+J) .NE. IREP1(J,I)) GO TO 250
  210 CONTINUE
C
C     GET NEXT NON-BLANK CHARACTER - ENSURE IT IS A '(', OR IS
C     'DOUBLE PRECISION' STARTING IN COLUMN 7.
C
      J = IOFFSET + L
C
  220 J = J + 1
      IF (J .GT. 72) GO TO 250
      IF (LINE(J) .EQ. BLANK) GO TO 220
      IF (LINE(J) .EQ. LEFTP) GO TO 230
      IF (I.GT.1 .OR. ICOL.NE.7) GO TO 250
  230 CONTINUE
C
C     REPLACE STRING WITH JREP1.
C
C     IF (IPRINT .EQ. 0) WRITE (6,9992) LINE
C9992 FORMAT (' CDCCONV, BEFORE CONVERSION: ',80A1)
C     IPRINT = 1
      DO 240 J=1,L
  240 LINE(IOFFSET+J) = JREP1(J,I)
      ICOL = IOFFSET + L
C     WRITE (6,9993) JREP16(I), LINE
C9993 FORMAT (' AFTER CONVERSION(',A16,'): ',80A1)
      NUSED(I) = NUSED(I) + 1
      GO TO 100
  250 CONTINUE
C
      GO TO 100
C
C     ENTRY CDCSET
C
C     THIS ENTRY POINT PREPARES ROUTINE CDCCONV FOR THE CONVERSION.
C
      ENTRY CDCSET
C
C     GET LENGTH OF EACH STRING TO BE SEARCHED FOR, AND A LIST OF FIRST
C     CHARACTERS.
C
      MINLENGT = 16
      NFIRST = 0
C
      DO 8200 I=1,NREP
      NUSED(I) = 0
      I1 = IREP1(1,I)
      IF (NFIRST .EQ. 0) GO TO 8050
      DO 8010 J=1,NFIRST
      IF (IFIRST(J) .EQ. I1) GO TO 8100
 8010 CONTINUE
C
 8050 NFIRST = NFIRST + 1
      IFIRST(NFIRST) = I1
C
 8100 L = 0
      DO 8110 J=1,16
 8110 IF (IREP1(J,I) .NE. BLANK) L = J
      LENGTH(I) = L
 8200 MINLENGT = MIN0 (MINLENGT, L)
C
      LASTCOL = 73 - MINLENGT
C     WRITE (6,9990) LASTCOL, MINLENGT, NFIRST, (IFIRST(I),I=1,NFIRST)
C9990 FORMAT ('0CDCSET: LASTCOL =',I4,', MINLENGT =',I4,', NFIRST =',I4,
C    1 ', IFIRST:',14(1X,A1))
C     WRITE (6,9991) (I,IREP16(I),JREP16(I),LENGTH(I),I=1,NREP)
C9991 FORMAT (1X,I3,3X,A16,3X,A16,3X,I4)
      RETURN
C
C     ENTRY CDCDUMP
C
C     THIS ENTRY POINT DUMPS THE CONVERSION STATISTICS.
C
      ENTRY CDCDUMP
C
      WRITE (6,8500)
 8500 FORMAT ('1FUNCTION NAME CONVERSIONS PERFORMED:'/
     1 '0STRING',11X,'REPLACEMENT',8X,'# TIMES'/)
      DO 8510 I=1,NREP
 8510 WRITE (6,8520) IREP16(I), JREP16(I), NUSED(I)
 8520 FORMAT (1X,A16,1X,A16,I10)
      RETURN
      END
